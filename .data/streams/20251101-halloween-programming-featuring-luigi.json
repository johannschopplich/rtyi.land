{
  "stream_context": {
    "summary": "Kaze outlines several core mechanics (four cap powerups, one-star side levels), implements and tunes koi fish AI for a village/pond area (random roaming, flocking, smooth turning), and iterates on a star concept involving crabs threatening the fish. He also discusses persistent “secret” coins saved to EEPROM for a long-term trolling gag, plus uncertainties around Luigi’s final role (unlock vs multiplayer) and practical platform/compatibility issues like byte-matching and iQue Player behavior.",
    "level": ["Overworld"],
    "significance": "notable",
    "significance_reason": "The stream contains concrete design commitments (crab-star concept revision, persistent secret coin behavior), substantial technical progress on a signature ambient system (koi AI + tuning + to-do list), and reveals major unresolved product questions (Luigi/multiplayer plan, voice approach, iQue/byte-matching constraints)."
  },
  "findings": [
    {
      "topic": "design",
      "importance": "medium",
      "summary": "The hack will feature four cap powerups: Wing Cap (Mario 64-style), Ice Cap (Galaxy-like but without shooting ice), Bomb Cap (throw bombs), and Cloud Cap (spawn clouds). Kaze explicitly does not want Metal/Vanish caps in this project, calling them unfun.",
      "quote": null
    },
    {
      "topic": "design",
      "importance": "medium",
      "summary": "Kaze states a firm structure rule: each side/secret level has exactly one star, with no exceptions.",
      "quote": null
    },
    {
      "topic": "technical",
      "importance": "high",
      "summary": "A “secret/rare coin” system is implemented using EEPROM bits: collecting the special coin sets a save flag so it won’t respawn as the special version; on revisits it spawns as a normal small coin instead (creating a deliberate fake-out for players who try to show friends).",
      "quote": "People will find one of those secret coins… and then they’ll tell their friends… and they go there again. Please, get trolled!"
    },
    {
      "topic": "design",
      "importance": "high",
      "summary": "The koi feature is designed as both ambient life and a quest-state signal: koi swim between randomized goal points and loosely follow each other; after you’ve “saved” them, they’re intended to circle near the middle island/central area when you approach, implying a visible ‘restored’ ecosystem state.",
      "quote": null
    },
    {
      "topic": "technical",
      "importance": "high",
      "summary": "Kaze implements koi movement logic (building an array of fish by iterating object list order) and adds per-fish randomized velocity. He then tunes turning/swaying to avoid robotic motion, discovering he had min/max logic wrong and adjusting divisors to hit a “delicate balance” between no sway and over-sway.",
      "quote": null
    },
    {
      "topic": "technical",
      "importance": "high",
      "summary": "Two major koi problems emerge during testing: (1) fish sometimes get stuck in specific spots, likely due to unreachable goals/collision edge cases; (2) fish can clip through floors or end up far below the water surface. Kaze ends with explicit to-dos to address swim-away behavior, anti-clipping, and stuck prevention.",
      "quote": null
    },
    {
      "topic": "design",
      "importance": "medium",
      "summary": "Kaze decides koi are not for a fishing mini-game; they exist ‘for the sake of it’ as atmosphere and a local gameplay beat, and he rejects ideas that imply Yoshi is for fishing.",
      "quote": "We’re just making kois for the sake of it."
    },
    {
      "topic": "design",
      "importance": "high",
      "summary": "The original crab-star plan (a crab appears and you simply ground-pound it for a star) is deemed too simple. Kaze pivots to a more involved encounter near the pond area: multiple crabs that retract into shells when ground-pounded, requiring you to hit them all (potentially within a time limit) while they disperse/attack and can re-emerge if you’re too slow.",
      "quote": null
    },
    {
      "topic": "design",
      "importance": "high",
      "summary": "Luigi’s role is still undecided: Kaze suggests there’s a good chance Luigi becomes permanent, but he’s not sure whether Luigi is unlocked at the end or whether the game will support full multiplayer. He strongly dislikes the idea of locking multiplayer behind beating the game once.",
      "quote": "What would be the most evil thing is if there is a multiplayer but you have to unlock it by beating the game once. God, I hate when games do that."
    },
    {
      "topic": "technical",
      "importance": "medium",
      "summary": "Kaze notes the project currently runs on the iQue Player, and mentions building a ROM that works across NTSC and iQue/China. He reiterates that byte-matching matters and implies non-byte-matching can introduce uncertainty about behavior parity across builds.",
      "quote": null
    }
  ],
  "contributor_findings": {
    "biobak": [],
    "badub": [],
    "zeina": [],
    "others": [
      {
        "name": "Jinjo",
        "findings": [
          {
            "topic": "technical",
            "importance": "medium",
            "summary": "Kaze credits Jinjo with helping verify iQue Player compatibility; the same ROM/build currently runs fine on iQue.",
            "quote": null
          }
        ]
      }
    ]
  },
  "memorable_quotes": [
    {
      "speaker": "Kaze",
      "quote": "People will find one of those secret coins… and then they’ll tell their friends… and they go there again. Please, get trolled!",
      "context": "He describes the EEPROM-backed rare coin that downgrades into a normal coin on revisit, turning a discovery into a long-term prank."
    },
    {
      "speaker": "Kaze",
      "quote": "What would be the most evil thing is if there is a multiplayer but you have to unlock it by beating the game once. God, I hate when games do that.",
      "context": "While discussing Luigi’s uncertain purpose, he reveals a strong design philosophy about accessibility and not gating social features behind completion."
    }
  ],
  "key_stories": [
    {
      "title": "EEPROM-backed ‘rare coin’ prank mechanic",
      "summary": "Kaze explains a persistent collectible system where a special coin permanently changes after collection. The real aim is social: players who try to show friends the ‘secret coin’ later will find only a normal coin, turning the discovery into a delayed joke.",
      "challenge": "Make rare/secret coins persist across sessions while avoiding repeated farming—and intentionally create a surprise on revisits.",
      "process": "He programs the coin to set a bit in the EEPROM save file when collected. On subsequent loads, the game checks the bit and spawns a small/normal coin instead of the rare one.",
      "outcome": "System is in place and Kaze is excited about the long-tail payoff of players being ‘trolled’ years later.",
      "key_quote": "Please, get trolled!",
      "related_to": ["kaze"]
    },
    {
      "title": "Building koi fish AI that feels alive (and doesn’t break)",
      "summary": "Kaze implements koi that roam among randomized points, loosely follow each other, and eventually should behave differently after being ‘saved.’ The bulk of the stream is iterative tuning: speed, turn smoothing, sway motion, and diagnosing why fish get stuck or clip out of bounds.",
      "challenge": "Create believable fish motion in a constrained N64-era engine without proper skeletal/bone animation, while keeping behavior stable (no stuck fish, no clipping through land).",
      "process": "He creates a fish array, randomizes velocities, adds line-of-sight checks, and tunes angle/turn behavior. He debugs erratic rotation (over-rotating past 180°), tests whether emulator randomness is skewing behavior, and identifies repeated stuck locations and depth glitches.",
      "outcome": "Kaze reaches a ‘good enough’ baseline behavior and ends with a concrete to-do list: make fish flee Mario before they’re saved, and prevent clipping through floors/onto land; the stuck-fish root cause remains unresolved.",
      "key_quote": "I think I’m happy with the fish now. They just need some animations, and then they’re very pretty.",
      "related_to": ["kaze"]
    },
    {
      "title": "Crab-star concept evolves from trivial to a timed multi-target encounter",
      "summary": "Kaze rethinks a star objective tied to the pond ecosystem. He rejects a too-simple ‘ground pound crab once’ solution and instead designs a multi-crab mechanic with shell-retraction and a time-pressure loop, better matching a full-star reward.",
      "challenge": "Make the crab encounter feel like a real star objective (not a one-move gimmick) while keeping it thematically fitting for a peaceful village/pond setting.",
      "process": "He explores options (single big crab chase, fight elsewhere near nets, gang of crabs). He lands on a system where ground-pounding forces crabs into shells and you must hit all crabs before they re-emerge; they may disperse and attempt to attack after the first hit.",
      "outcome": "Direction is chosen (“we go with the crab”) with a clearer mechanical hook; implementation details (AI, time limit, attack patterns) are still to be built.",
      "key_quote": null,
      "related_to": ["kaze"]
    }
  ],
  "open_questions": [
    {
      "topic": "Why do koi get stuck and how will the final ‘anti-stuck’ solution work?",
      "context": "Fish repeatedly get stuck in specific spots and sometimes appear to chase unreachable goals. Kaze suspects goal generation/collision edge cases but doesn’t fully understand the cause yet, and also flags clipping through floors/onto land as a to-do.",
      "questions": [
        "Can you walk me through the first time you noticed the koi getting stuck—was it a collision bug, goal selection, or water-surface math?",
        "What debugging tools or visualizations did you use (or wish you had) to identify whether a fish is chasing an unreachable goal versus colliding?",
        "What final solution did you settle on: goal re-rolls, nav constraints, push-out physics, or a custom ‘water volume’ boundary system? How did it affect performance and feel?"
      ],
      "related_to": ["kaze"]
    },
    {
      "topic": "Final design of the crab star: mechanics, readability, and tone",
      "context": "Kaze commits to a crab-based star but is still shaping what ‘the fight’ is—single big crab vs multiple crabs, shell retraction, time limits, and location near the pond/net so players intuit what to do.",
      "questions": [
        "What did your first playable version of the crab-star look like, and what player behaviors did it encourage that made you say ‘this is too simple’ or ‘this feels unfitting’?",
        "How did you plan to telegraph the shell-retraction + time limit idea so players understand the rule without text?",
        "Did the crab-star end up being more of a combat encounter, a timed challenge, or an environmental ‘rescue’ puzzle—and why?"
      ],
      "related_to": ["kaze"]
    },
    {
      "topic": "Luigi’s role and the multiplayer decision (and how it impacts production scope)",
      "context": "Kaze says Luigi may be permanent, but he’s undecided between an endgame unlock and ‘full-on multiplayer.’ He also discusses needing a Luigi voice solution and dislikes gating multiplayer behind completion.",
      "questions": [
        "At what point did Luigi move from ‘fun idea’ to a serious feature you had to plan around, and what forced that decision?",
        "What constraints (camera, level layout, netcode/local input, performance) made multiplayer feel feasible or infeasible on this engine?",
        "How did you resolve the tension between rewarding completion (unlockables) and not locking key experiences like multiplayer behind the credits?"
      ],
      "related_to": ["kaze"]
    }
  ]
}
