{
  "stream_context": {
    "summary": "Kaze showcases and begins using Sauraen’s new trace+profiler to diagnose RTYI frame-time, then pivots into active production work: iterating Course 13’s snow/slide/cave route (including a prior memory-crash root cause) and importing/optimizing Biobak’s “Oily Boily Bay” assets to reduce materials/bones and hit stable performance. The stream ends with a substantial AI/pathing bugfix for the Wiggler actor and continued NPC asset integration.",
    "level": ["Course 13", "Overworld"],
    "significance": "milestone",
    "significance_reason": "A new, team-built profiler becomes operational and immediately changes how Kaze understands frame-time (idle/memory waits, RSP/RDP balance). In parallel, the stream captures concrete performance-driven art pipeline decisions (materials, bones, fog, texture formats) and resolves a core gameplay actor bug (Wiggler pathing + facial animation states)."
  },
  "findings": [
    {
      "topic": "technical",
      "importance": "high",
      "summary": "Sauraen’s new tool functions as both a trace and profiler, letting Kaze visualize per-thread/per-task timing (idle thread, game loop, VI manager, audio, RSP task) and see how tasks interrupt each other (e.g., VI manager interrupted by audio).",
      "quote": null
    },
    {
      "topic": "technical",
      "importance": "high",
      "summary": "Profiler reveals RTYI spends ~25 out of 33 ms per frame in an idle loop (about 76% of the frame), i.e., much of the frame is the game “doing nothing,” which Kaze interprets as waiting—likely memory/scheduler-related rather than pure CPU compute.",
      "quote": null
    },
    {
      "topic": "technical",
      "importance": "medium",
      "summary": "Kaze notices the game loop appears late in the frame and suspects a missing “RSP done” signal (or other scheduling/synchronization issue) could be blocking the game loop despite no obvious blocking work in that interval.",
      "quote": null
    },
    {
      "topic": "technical",
      "importance": "high",
      "summary": "Kaze observes the RDP running longer than expected relative to the GFX/RSP work, reads it as a bottleneck signal, and notes unusual runtime for the scheduler/VI manager/inactive render thread—driving a focus on render and scheduling efficiency.",
      "quote": null
    },
    {
      "topic": "design",
      "importance": "medium",
      "summary": "Course 13 layout work: Kaze presents a “snowman path” into a “snowman cave” where the player dodges snowman attacks, intentionally echoing a Jolly Roger Bay-style traversal section (climb/pressure) inside a new thematic context.",
      "quote": null
    },
    {
      "topic": "design",
      "importance": "medium",
      "summary": "Course 13 includes a long slide over an abyss with a helix-like segment, an ice block intended as a jump/landing/launch element, and a wall-kick section; Kaze accepts some difficulty because it’s Course 13 but flags the current slide as slightly too punishing/chaotic.",
      "quote": null
    },
    {
      "topic": "technical",
      "importance": "high",
      "summary": "Kaze explains a past Course 13 slide iteration crashed due to collision memory: in Mario 64, collision triangles crossing multiple spatial cells require additional “surface nodes,” and the slide’s size caused excessive node allocation and a crash.",
      "quote": null
    },
    {
      "topic": "technical",
      "importance": "medium",
      "summary": "A prior fix for the slide’s memory issue led Kaze to implement/adjust memory allocation (referencing his recent Case Clips video), which he says also yielded about 400 microseconds of computing time improvement—showing how level geometry can force engine-level optimization work.",
      "quote": null
    },
    {
      "topic": "design",
      "importance": "medium",
      "summary": "To make the slide fairer, Kaze considers raising camera horizon via scaling the slide down (instead of tilting the camera up) and makes adjustments so hazards are visible earlier.",
      "quote": null
    },
    {
      "topic": "technical",
      "importance": "high",
      "summary": "Kaze confirms RTYI input/angle precision is much higher than vanilla Mario 64: Mario 64 uses 4096 angles, while RTYI uses 65,336 angles. He attributes this to speed-driven trig changes (polynomial approximations replacing lookup tables), which also increased accuracy; this can change how precise-angle speedrun setups behave (e.g., carpetless).",
      "quote": null
    },
    {
      "topic": "technical",
      "importance": "high",
      "summary": "Biobak’s Oily Boily Bay asset update focuses on render cost reduction: fewer materials, texture/format choices (switching to RGBA16 when CI is impractical due to too many unique colors), and adding fog for visual cohesion while also improving perceived quality.",
      "quote": null
    },
    {
      "topic": "technical",
      "importance": "medium",
      "summary": "Kaze identifies a Fast64 export behavior/bug affecting fog visibility and texture format selection (Fast64 auto-picking CI incorrectly without detector-type checks), reinforcing that tooling quirks actively shape the pipeline.",
      "quote": null
    },
    {
      "topic": "technical",
      "importance": "medium",
      "summary": "Kaze notes new “step function” behavior likely affects collision/physics, making it easier to clip through tox boxes; he treats this as a real gameplay issue to address (collision feel vs performance/engine changes).",
      "quote": null
    },
    {
      "topic": "technical",
      "importance": "high",
      "summary": "A major Wiggler actor bug is diagnosed as path logic error: Kaze was effectively treating waypoints as jump thresholds and skipping them, causing erratic turning. He removes the unnecessary logic and restores proper trajectory end handling, resulting in stable path following plus facial animations when Wiggler gets upset.",
      "quote": null
    },
    {
      "topic": "milestone",
      "importance": "medium",
      "summary": "With Biobak’s optimizations (bones/material reductions across multiple NPCs and props), Kaze believes Oily Boily Bay should now sustain 30 FPS “pretty easily,” suggesting the level is approaching a performance-stable state.",
      "quote": null
    }
  ],
  "contributor_findings": {
    "biobak": [
      {
        "topic": "technical",
        "importance": "high",
        "summary": "Biobak delivers a large batch of updated Oily Boily Bay assets with explicit performance notes: reduce materials (e.g., baking helmet straps into textures), reduce bones (e.g., both legs sharing one bone), and update geo/collision to match the modernized look.",
        "quote": null
      },
      {
        "topic": "design",
        "importance": "medium",
        "summary": "Biobak pushes visual direction via texture refreshes and prop redesigns (tox boxes fitting the world better, glass texture update, construction/junkyard aesthetic coherence), with Kaze reacting positively to the improved integration.",
        "quote": null
      }
    ],
    "badub": [],
    "zeina": [
      {
        "topic": "personal",
        "importance": "medium",
        "summary": "Zeina appears in chat early; later, Kaze references their unborn child’s name (Reyna) while joking about family dynamics—highlighting the project’s development occurring during an active life transition (impending birth/paternity leave).",
        "quote": null
      }
    ],
    "others": [
      {
        "name": "Sauraen",
        "findings": [
          {
            "topic": "technical",
            "importance": "high",
            "summary": "Sauraen’s profiler/trace tool becomes central to Kaze’s workflow, enabling thread/task timing breakdowns that immediately expose idle/wait time dominance and scheduling oddities.",
            "quote": null
          },
          {
            "topic": "technical",
            "importance": "medium",
            "summary": "Kaze recalls Sauraen warning that an old “zero normals” rendering trick won’t work with F3DEX3 because the microcode auto-normalizes normals, constraining certain shading hacks.",
            "quote": null
          }
        ]
      },
      {
        "name": "Lilaa",
        "findings": [
          {
            "topic": "technical",
            "importance": "low",
            "summary": "Lilaa is pulled into troubleshooting Blender/Fast64 export issues (normals/sharp edges and expected shading behavior), illustrating the community-as-support loop when toolchain edge cases block progress.",
            "quote": null
          }
        ]
      }
    ]
  },
  "memorable_quotes": [
    {
      "speaker": "Kaze",
      "quote": "25 out of 33 milliseconds are spent on a while(1) loop. It’s all idle. It’s around 76% of the entire game—it’s just the game doing nothing at all.",
      "context": "The profiler’s most documentary-friendly reveal: on real hardware timing, most of the frame is dominated by idle/waiting rather than active gameplay code, reframing what “optimization” means on N64."
    },
    {
      "speaker": "Kaze",
      "quote": "Dude, I’m still on two months of paternity leave. I’m gonna spend that time trying to optimize the operating system on my N64.",
      "context": "A personal-life-meets-obsession line that captures the project’s tone: intense low-level engineering continuing alongside impending parenthood."
    }
  ],
  "key_stories": [
    {
      "title": "The profiler exposes RTYI’s frame as mostly idle/wait time",
      "summary": "Kaze debuts a new trace+profiler from Sauraen and immediately discovers that the majority of a frame is consumed by idle looping rather than game logic. This shifts the optimization narrative from “make code faster” to diagnosing scheduling, signaling, and memory wait states on N64.",
      "challenge": "Performance tuning was constrained by poor visibility into where frame time was truly going and which threads/tasks were blocking others.",
      "process": "Kaze limits FPS for consistent measurements, reads the timeline of idle/game loop/RSP/audio/VI manager activity, and reason-checks suspicious ordering (game loop late in frame) and interruptions (audio preempting VI manager).",
      "outcome": "He identifies the dominant idle portion (~76%) and forms hypotheses about synchronization issues (e.g., missing RSP-done signal) and bottlenecks (RDP vs GFX timing), setting the direction for future optimization work.",
      "key_quote": "25 out of 33 milliseconds are spent on a while(1) loop. It’s all idle.",
      "related_to": ["kaze"]
    },
    {
      "title": "Course 13 slide: a level-design problem turns into a collision-memory crash",
      "summary": "While reviewing Course 13’s slide section, Kaze recounts how the original slide build caused a hard crash due to collision memory limits. The incident shows how ambitious geometry can trigger deep engine constraints and force low-level memory allocation changes.",
      "challenge": "A large slide’s collision mesh exceeded Mario 64’s collision data structures, crashing the game due to excessive surface node allocation.",
      "process": "Kaze explains the underlying mechanism: collision triangles spanning multiple spatial cells require extra surface nodes; the slide’s scale multiplied that cost. He then reworked memory allocation (as discussed in a recent video) and later revisits gameplay fairness by adjusting visibility/camera considerations instead of camera-tilt hacks.",
      "outcome": "The crash was resolved via allocation changes, with a reported side benefit (~400 microseconds compute time gained). The slide remains under iteration for readability and difficulty tuning.",
      "key_quote": "Every time you have a collision triangle that crosses into multiple cells... you have to allocate two surface nodes. And because the slide was so big... the whole thing just crashed.",
      "related_to": ["kaze"]
    },
    {
      "title": "Oily Boily Bay hits performance stability through art-pipeline constraints",
      "summary": "A massive Biobak asset drop becomes an optimization pass in disguise: materials, bones, texture formats, fog, and collision are all evaluated through the lens of frame rate. The story captures the constant negotiation between visual ambition and N64-era budgets.",
      "challenge": "Oily Boily Bay’s scene complexity risked missing 30 FPS; tooling (Fast64) and N64 render constraints amplified costs (materials, CI palette limits, fog interactions).",
      "process": "Kaze audits assets top-to-bottom, adopts Biobak’s ‘fewer materials/bones’ notes, switches texture formats when CI is infeasible (too many colors), and uses fog both to improve look and unify the scene. He also flags collision/clipping side effects from engine changes (step function).",
      "outcome": "Kaze concludes the level should now run at 30 FPS “pretty easily,” implying the asset pipeline changes are paying off and the level is nearing a performance-ready baseline.",
      "key_quote": "Dang, I think we can get Oily Boily Bay at 30 FPS now.",
      "related_to": ["kaze", "biobak"]
    },
    {
      "title": "Wiggler’s broken pathing is traced to waypoint-skipping logic",
      "summary": "A seemingly mysterious AI movement bug (random turning, ignoring path end) turns out to be self-inflicted logic: waypoints were treated like jump thresholds and skipped. Fixing it restores predictable navigation and enables facial animation states, showing how gameplay feel depends on tiny control-flow decisions.",
      "challenge": "Wiggler turns too early, runs in wrong directions, and fails to respect trajectory end conditions, making the actor unreliable.",
      "process": "Kaze instruments the logic with prints, verifies expected “trajectory end = -1” behavior, and discovers he was skipping waypoints if they were beyond a velocity-based threshold. He removes the unnecessary behavior and re-tests until movement stabilizes.",
      "outcome": "Wiggler follows the path correctly again, and facial animations play when he becomes upset, clearing a blocker for that actor’s integration.",
      "key_quote": "No wonder that was confusing, but there was no reason for this to exist—so now it’s just removed.",
      "related_to": ["kaze"]
    }
  ],
  "open_questions": [
    {
      "topic": "How does the profiler change the team’s optimization roadmap?",
      "context": "The profiler suggests RTYI spends the majority of the frame idle/waiting, and Kaze suspects signaling/scheduling issues (e.g., missing RSP-done) rather than raw compute.",
      "questions": [
        "When you first saw that ~76% idle time, what did it change about your mental model of N64 performance for RTYI?",
        "Did the profiler lead to any concrete engine changes in later streams (scheduler tweaks, RSP task synchronization fixes, memory wait reduction)?",
        "What would you consider a ‘win’ now: reducing idle time, shortening RSP/RDP tasks, or making the frame pacing more consistent?"
      ],
      "related_to": ["kaze", "biobak"]
    },
    {
      "topic": "Angle precision and speedrun compatibility",
      "context": "Kaze says RTYI uses 65,336 angles vs Mario 64’s 4096, making controls ~8× more precise; this may alter established setups like carpetless.",
      "questions": [
        "Was higher input precision an explicit design goal, or an accidental consequence of the performance-motivated trig rewrite?",
        "Do you want RTYI to preserve ‘classic’ Mario 64 tech feel, or embrace a slightly different movement meta that rewards modern precision?",
        "Have you considered adding an optional ‘vanilla precision’ mode for competitive or nostalgia-focused players?"
      ],
      "related_to": ["kaze"]
    },
    {
      "topic": "Designing large slides under collision memory constraints",
      "context": "Course 13’s slide crashed due to collision triangles spanning multiple cells and exploding surface-node allocation.",
      "questions": [
        "After that crash, did you establish any internal rules of thumb for collision complexity (triangle size, cell boundaries, mesh segmentation) when designing big geometry?",
        "How do you balance the desire for huge set-piece geometry (like long slides) with the hidden costs of Mario 64’s collision system?",
        "What was the ‘memory allocation thing’ you changed—was it a one-off patch for the slide or a broader engine improvement you now rely on everywhere?"
      ],
      "related_to": ["kaze"]
    },
    {
      "topic": "Performance-driven art direction decisions in Oily Boily Bay",
      "context": "Biobak’s updates reduce bones/materials and Kaze switches texture formats (CI vs RGBA16), adds fog, and evaluates render cost as part of the look.",
      "questions": [
        "How do you and Biobak negotiate visual targets versus hard budgets—do you set a ‘materials per actor’ or ‘bones per rig’ guideline?",
        "When you choose fog, is it primarily aesthetic, performance-motivated (hiding distance detail), or both?",
        "What are the most painful toolchain limitations (Fast64 quirks, CI palette limits, environment color interactions) that repeatedly shape your final art style?"
      ],
      "related_to": ["kaze", "biobak"]
    }
  ]
}
