The half hit ball and it but but it the all  Am I second? You are second indeed. Hello Biobak. Hello Zeina. Hello Super Mario Lover. Cave it? How am I cave it? Sub! 44 months, that's a long ass time. Hey guys, hi Zeina. Sorry for being late, but congrats on becoming parents. Being late? Dude, I just started streaming. Oh, you mean being late on the congrats. It's okay, you are forgiven. The baby is currently hanging out with her grandparents. Yeah, Zeina is having a lot of fun with the baby. The little munchkin or whatever. Hello Velzeh. Hello Imagine Net Studios. Hello Bingus. Hello Lila. Space Yoshi rapper remix. This song? No. But I absolutely should make a rap song about Space Yoshi at some point. It would be extremely funny. Show your baby on stream? You go first. Prove that you have a baby. Romancas can't have babies. This is unbelievable. It's so funny. Every time I upload a video that I show my face and everyone's always like, Kaze, you're so much muscle. How is this possible? Every time people are shocked I knew for some reason. Did you forget we have a rapper Yoshi song? I know we have a rapper Yoshi song, but it's not based on this song. It's based on Hopper Hopper. Hopper. Yoshi. That one. I guess. What are the changes since last time? This room now looks decent. It's still not good, but it no longer looks like complete ass. I kind of like this ice carpet here. I think it's a nice touch. Hello Skyloft Sword. Have you considered cutting? You would look ripped. Yes, but I'm kind of just in it for the long term. And I think long term not cutting right now is the better choice. I usually cut like once a year. I was planning to cut again, I think after Christmas. Christian cross on the ground. It's not quite the Christian cross. It's a little right heavy. Oh yeah, we should listen to this level with the music. So this section changed a little bit. I made a lot of progress since I skipped one week of streams. Oh, that's OK, Biobak. I have a video bench for soon anyway. My editor has been on it for a week. And after that, it's going to be the demo. So we have a few more weeks. We have this room here, which I think is pretty cool. It's like, how do I get over there? Oh, that's how. Crash. It shouldn't have crashed there. That is a problem. I mean, just emulate like for console compatibility. Accuracy. They want to just get accurate. Just pure white doors are going to be there in the final. Yes, they're actually separate rooms. So by having a door like this, I can make it so that the room behind here doesn't render right now. And then as soon as I get here, I make the room render. What the hell is going on? Yeah, so I recently made some changes with Layer 5 and Layer 6. Layer 6 is transparent decals. Layer 5 was just transparent to invert the order. Because you have to render transparent stuff in Z order. And decals are much more likely to be behind non-decals. So we want to render the decals first. I can absolutely use. Can I use other? I can use noise. Probably. I imagine you come closer and there's like a noise filter here. That would work. Yeah. And then we have this section here, which is also not done yet. But I finished all the platforming inside the castle. Right now we just have to make the castle look good. I got this section here with the big boys shooting fire at me. Then we got the section here with the toxic ice. We got a path here that gets skinnier and skinnier. And walking along it gets difficult.  But it's manageable. Then we got a far jump here. We got more paths that go skinnier. I think the difficulty here is appropriate for CoS 13. Alexara clone. And then right here, this will be a mirror. And there will be a wallkick section. On the mirror. So it will look like you're punching wallkick mirror Mario. What's the plan if you miss the slide at any point? I can show you. So let's say you are a little newbie and you miss the slide. First of all, if you fall down here, you can still save yourself like this. And then on the slide there's usually 5 coins that will heal you. And then if you miss this... Well, it sucks for you, but... There's a line of coins guiding you to safety. And right here you can heal. And then if you fall down here, well, you can just kinda book it. So I think it's fair. Is the HP circle supposed to be stretched? No. Yeah, I think it's good enough this way. What else is new? We got a few changes in this area here. The ice miss looks great. The damage is pretty good. Did I show this on stream? This whole section here. This is what we were working on last week. I finished it off stream. There's some pretty cool thing here. Let me show you. Doing this combined I took a bit, but you see how it just disappears into the clouds here? I like that a lot. And then the sunflower is here. It's so cute. I also want a new grind animation here for Mario. The one we have right now is not it. No, Mario.   It's saveable. There we go. But would you ever use for custom draw layers? I mean, I would like to be able to use layer 7 sometimes, which I already do. But more than that, no. Was the spin animation loop something you added? Yes. You can add a cloud object at the top that is offset from the center on its Z-Normal and always rotated towards Mario. Offset on its Z-Normal. Yeah, yeah, I see what you mean. That could work. And by the way, today is likely going to be a special stream with Sauraen as a guest. Because he wants to talk about X3 stuff again. We might be able to get around 300 microseconds of performance in X1 for free. And then a lot more performance globally in the entire game for free. Which would be really cool. I like these spikes. They got some nice charm to them. We got Sora Sorans. How could you confuse these two? Hello, Deku. Hello, Marvel Fanta. You are cooking good. Alright, alright. I'm not doing Banjo-Kazooie last impact. No shot. I'm not doing Banjo-Kazooie last impact.  Hmm. This room still feels pretty barren. I think we actually need more enemies. I also don't like this texture here. This texture here looks pretty poopy. You add a respawn event, Mario must be seen in cold levels. I have not added that as a feature. Banjo is not shiftable yet. It is shiftable. I got a message today from Mitten saying, Wow, you called in a favor from a friend and he made it shiftable. And I got a message from Vaisky, Hey, I just worked on the Banjo decomp, I made it shiftable. Oh, I'm not doing Banjo-Kazooie last impact.  Of course, it's Vaisky. Who else but Vaisky. He thought he was working on it. He was working on it and then he finished working on it. Hello, Voisel. I agree, Jonathan. This one feels very different from the rest of the games. And from the rest of the game. Voisel. Vaisky sent me that you will never escape from the Simpsons once. I mean, if he's enjoying it, why would he want to escape, you know? Oh, God. This still looks like shit. Hey, Sideshed. How was your No Fentanyl Friday last night? Mine was tough, haha. I haven't done Fentanyl in a while, so. Is it possible to make the game run 60 FPS? Banjo-Kazooie 60 FPS consistently seems tough. I don't want to say it's impossible, but I don't want to say it's impossible. But I will say it's unreasonable. How is Lilaa such a coffee addict? She keeps talking about how she wants to quit coffee and then she keeps talking about how much coffee she's been drinking that day. You listen to Femtanyl? That's a singer? And no, I have nothing to do with Fentanyl. I was just replying to a comment message. Right, so Rare already implemented optimizations that weren't made for SM64. Okay, what Rare did in Banjo, from what I've heard, I cannot talk about. Because if I talked about it, you guys would hate me. Because I would talk very poorly about it and people think Rare is like the goat of the N64. I'm about to fail a fucking QuickTime event and go on a full rant about how terrible Banjo-Kazooie optimizes. Fentanyl is Zuma Music? I imagined with a name like that. Make a Rare rant video? Nah. Yeah, it's true. It's nothing they could have done. Yeah, you know what? It was in 1990x. We couldn't have known that decompressing a fucking code segment was slow. Yeah. What's wrong with that name? Well, first of all, it's called Femtanyl. As in like Femboy Fentanyl. Which that's the most fucking Zuma thing ever. Talking about naming yourself after your gender. That's a Zuma thing. And then also Fentanyl, the drug. That's also like a Zuma thing to just talk about Fentanyl. Like it's a joke. Why would you say Femboy? Because they're called Femtanyl, not Fentanyl. Wait, okay, I'm googling them. Femtanyl. Music. Okay, I googled them. Look at this. You're telling me this doesn't look like Zuma bullshit? Casey's family thinks Femboy interesting. Yes. What do you think when you hear that? Casey, you need to heal. I am fully healed. You think Fem? That's not a word. I think Fem as in feminine. Sure. I'd like to hear about the rant from Rare. Okay, I don't know that much about Rare. I just heard that during gameplay, they are loading and decompressing data. Instead of loading at that level start. Which there definitely is enough RAM for. Which is really bad. Because decompressing codes, relinking codes, loading data from memory, from ROM. All that at runtime. Causes a lot of lag. For sure. And then Conker's Bad Fur Day. They made it 192p. Because the game just ran too poorly at 240p. You can't tell me that's like impressively made. It's just. We added too much shit. Oh no. I guess time to lower the resolution. So this is still playable. And then I watched the devs play through Conker's Bad Fur Day. And they were saying like. Oh, you know what? You can tell if a game is good. By seeing whether your character reacts to walking into walls. Because if he doesn't push against the wall. That means it's a bad game. And then they play the game. And they get a transformation. And they walk into a wall. And the character doesn't push against the wall. And they don't even acknowledge it. Then I go. Well, I guess we didn't. I guess that point doesn't count anymore. Being such a snobby asshole. And then you don't even live up to your own standards. Fuck you. I'm about to get cancelled. Real life is a bad game, you do not react to walking into walls, you just keep doing your walk animation. Hello Spaghetto. No, you just bump into- well, then you're at least doing an animation. I gotta keep Discord open in case Sauron comes online. He said he's gonna be here sometime shortly after the stream starts. Are you saying that like it's weird? Oh, you don't react at all to walking into walls? You just keep doing your walk animation? Your walk cycle? Upsetto Spaghetto? True, that's me. My cat doesn't push her paws towards the wall. PK-slash-beat-difficult still unmatched though. I'm sure Biobak is 100% serious about this statement and it's not a joke at all. Look at this shit, it's so beautiful. You know what? This is unfair. This is like not a realistic gameplay angle. At least the gameplay angle is like this, which still has some issues. That has to be a random bug, right? It doesn't actually look like this. I mean, the floor here looks really nice. You actually think this looks insane? It looks pretty nice, yeah. There is some jank with the UV mapping, but like, yeah. The way these textures fade here, I kinda like that. Like, I like the texture fades a lot. Although this is like a really small level. This barely even feels like a real level to me. Is there a BK-BT noclip that makes me dub my own skills? I don't know, I think the levels you're making are a lot prettier. I think 2E is 240p. Oh, I know Alila. I know the 3D models. Do you plan on doing Benji Kazooie stuff now that the game is finished? No, I haven't even beaten the vanilla game. Hmm. That's a good floor texture. Picking a floor texture here is so hard. I wonder if maybe there's something in unidentified floors. Something like that could actually work. Maybe with a slightly different color. I don't know. I kinda like it. If Yoshi does really like these 10 notes, I think it's kinda nice that there's a leitmotif. Enter the Zombies is such a cool game. I wish the sequels were any decent at all. Oh, guys. Are you ready to hear my opinion on Final Fantasy VII? Are you mentally prepared? I am gonna piss off so many people by saying this. No. Oh, no. Alright. Do you want to hear it? You're just gonna be etched with that information now. Do you think it's dog shit? Nope. Can I remember to play this for my case? Can you tell me how long it will be before the final release? I don't know, honestly. Tell us. Okay, fine. The game has a really cool vibe. It's really fun to just exist in the world. But goddamn, I hate JRPGs. I'm playing the Switch version where you have the free time speed modifier and still, literally 50% of the gameplay time is just me sitting there like this. Just attack. Just kill the enemy. I don't want to deal with this. This gameplay is so much better. That's interesting. Silence Case and Bean Girl are speaking. Alright, Bean Girl. Mrs. Bean. This might work. Instead of tuna shank, I should do a bean shank. No. Dustborn. I don't know.         That definitely looks like a game Twitter will love. Or maybe Twitter will hate it because this seems to criticize Twitter practices. Dude, what the fuck? Let me just see how it looks in game. It's owned by a government by the way, using taxes. Republican twitter hates it. Can it really be that bad then though? What do you think is the most obscure Mario 64 thing to have a fan art on? The cloud painting in the second story of the castle to the right when you go up the stairs. Oh, that's kinda nice. Did I make my first Mario 64 remake with Blender? Nope, I used Google Sketchup. It was not a good time. I like how twinkly everything looks here. Couldn't we also do a review of the Super Mario 64 invisible worlds? Yes, I did that. The retro section for this is Super Mario Land. It's a little dancing flower weather effect from the beta. There's a drone of it with huge boobs. Interesting. Alright, I think this room here we can consider it to be finished. Except for the UBC obviously, but that's at the end. It's very bright, I think too much. No, I like how bright it is. I actually don't like the way this thing looks. I think it needs to have darker edges. So let's fix that first. From Pilsenzo? No, no, no. Google Sketchup. That's from Google. Pilsenzo made Rob Manager in 2018. Which was 7 years after I started modding. Or maybe I made it in 2017. I remember in 2018 it was really usable though. How many stars in this? 7 stars, 12 levels, that's 84. And then a few extra, like 90, 100, something like that. What are you listening to? The Yoshi's Story OST. Will there be an outside area? Yes. It will be a little village with penguin huts. Zeina is actually working on some assets for it right now. It isn't by Google anymore. I don't know why.         Dang. I think it's too transparent. I think that's the issue here. Do you see my new Sketchup? I remember watching someone making OTLs. I don't know if that was you. No, that was not me. But I did stream some Sketchup. But not OK40. Saren is ready. Alright. Let's go. I don't know why.    Oops, I did that in all caps. Speedkick was sick. In this game speedkicks are two frame tricks, so you can just go sicko mode with them. Come on. Of course, now that I actually tried to go for it. Did you mean let's-a-go? Yes. Mexico. Mexico. Alright, I'm calling him. Wait. Setting up Discord. One second. You're coming out of my headphones, which I'm not using right now. Hello? Yeah, I'm here. Perfect. Alright, I'll put you on stream. Thank you. There he is. There's Saren. Alright. We're doing X3 stuff today. Let me get your stream up so I can actually see you. Your volume is a little low. Sorry. Why don't you... Let's see. So let me have some game volume here and see if that is audible also. Alright. How does the game sound? It should be quieter than my voice, but... It doesn't. Oh wait, you don't sound at all. Okay. How about now? I still hear nothing. Sorry, that was the Nintendo Switch I turned on. Is this a Saren? No. Now, I hear just a little bit. I can make it louder. I can make it a little louder for you too. How about that? I think your microphone is filtering it out or something. Oh, do I have voice cancellation? Yeah, it's also filtering it out. It's filtering your voice now. What's your anime girl in the server list? This is a struggle play. Alright, what about now? Oh yeah, that's much more visible. Audible.  Yeah, so if you guys don't know, this guy is Saren. He's working on a new microcode for the N64 called X3. F3DX3. It's like an evolution of F3DX2. And it is supposed to have a few performance benefits. And you get more vertices in the vertex buffer. So overall it will just be way better than X2. And hopefully this will give us a few more FPS. Okay, let me get out of this game playing sound here. I just got your stream up. I see your chat. Oh, the chat seems to be kind of emulated. Oh, the game is now louder than your voice. The game is now louder than my voice? Yeah. Fix that. Let me try that again. How is it now? Put it down like 3-4 decibels. Down more on the game. How about like this? That's better. So where do we want to start? So I guess I can start with giving you the latest version from last night. Which will hopefully improve performance for you. All right. I'm just going to make clean. So I have everything on X3. And you use make F3DX3 branch Z PNOC. Yeah, I'm not sure if I want to use branch Z or branch W for the final. But I think branch Z makes more sense. Yes, I've been giving you the latest version. I'm giving you that version because that's what SM64 used. But if you're never using the culling, then it doesn't matter. Because you're not going to ever do it. What's the GitHub link? Let me paste it to you and then you can paste it in chat. Because I think it will probably filter me. There you go. Someone already did the hard work for us. Yeah. Hi, Lila. Lilaa is one of the fast 64 devs. Anyway, so let me send you these. But, yeah, I have this list of things from a couple weeks ago. That I wanted to try. One second. I'm going to have to turn the stream off for a second. I hope this doesn't crash my OBS guy. All right. I think we're back online. Yes. Your stream just came back up. Hello. All right. I got the things in. Now I'm just going to change the text from branch W to branch C. For some reason, I use branch W at first. I don't remember what the exact difference is. But it seems like in the past, I deemed W to be better. There is one instruction difference. And it is. Where is it? HWZ. I'm guessing it takes a W component instead of Z. Yes. So, when on your branch Z or branch W GBI command. Which is for level of detail. So, you have a low level of detail mesh and a high level detail mesh. And depending on how far away from the camera it is, it picks one of them automatically. By branching to, like, it branches to the one that's, I think, the farther one. And, yeah. So, it can, with branch W, it loads the screen integer, like, screen space W component. And then if it's branch Z, it reads the integer and fraction Z component. Now, why would you, why am I still so quiet? Why am I still so quiet? Okay. I'll turn myself up. How about this? Is this any better Yoshi party? Anyway, so, yeah. So, if you're not using this branch WZ, if you're not using level of details, then it doesn't work. Matter so and if you are using it so there is an advantage for w which is that if you use a camera field of view to zoom in on far things which is basically not like moving the camera forward but just like zooming the camera in the w value will like in will decrease if it's like a farther object so it'll actually switch to a higher level of detail for zooming in on the which is right you want to have but if you have any like vanilla stuff in your game which i don't think you do it uses the command then you have to stick with the same command yeah makes sense so i have your thing in unfortunately um i don't know if you see this on my stream let me make this big for some reason whenever i use x3 the the profile numbers kind of go crazy so i was thinking we could try to debug that too um if you want but is this enough to to see what you wanted to see from this uh yeah should be good enough let's compare this to x2 real quick well so you got to turn off the uh like counters and stuff if you if you want to have the what well like it's spending a bunch of time not only drawing the text but drawing those bars right but yeah it looks like graphics is about maybe 300 300 microseconds faster now yeah and rdp almost a full millisecond that's crazy although this has a lot more idle thread time for some reason which is interesting and then i also have a version of it in limited fps mode that's oh fuck i moved one second yeah so Lilaa is asking vanilla ex2 or the custom ex2 it's um it's a custom one yeah it's the one that has um okay so let's see what this is now 200 milliseconds better and oh my god rdp almost a full millisecond over a full millisecond okay well are you satisfied oh yeah that's much better let's check the performance with nothing on here yeah that's pretty nice i think this is now an improvement i'm glad there's there's not much left to to squeeze out um well the next thing to squeeze out is gonna be um all the the extra comments you added right and the vertex buffer oh yeah yeah so um okay yeah so there's a there's a lot of things that we can talk about um do you want to talk about like one of the things or a couple of the things that i recently did to actually get some of this performance back yes yes that would be very interesting okay so um the the philosophy of ex3 just like over the last you know since i started it um it was it was just like started as oh you know oot is always rdp bound so it doesn't matter how much time the rsp takes you know as a first approximation and um let's you know make some interesting graphical effects and interesting writing stuff and so i i rewrote the vertex processing i um and part of that was also um so like when you have very very optimized rsp code there's you have to manually allocate all the registers so like you know register both the scalar registers and the vector registers so like scalar register you know 14 whatever is just a global variable that's always a certain use for a certain thing and like scalar register 9 is used for these three different things and on this code path it's used for this and this code path it's used for this and you have to make sure um that those code paths like never intersect and that you don't have like yeah you know two different things trying to use the same thing and so ex2 did that kind of stuff with the vertex writing and they had like a lot of stuff in registers basically you you have these loops in the in the rsp and you can have like data like the loop isn't just processing let's say one pair of vertices from the top to bottom it's processing like the center part like the middle group of commands for the for a given pair of vertices but it's also finishing the commands for the last pair of vertices and starting the commands for the next pair of vertices in the same loop this is like loop pipelining um and so they were just like carrying all these dependencies everywhere in registers and the registers were all disorganized and so the first thing i did way back you know like this is like a year and a half ago is i just rewrote it made everything really simple and i wasn't really looking at the performance numbers like i checked the time wasn't getting sense but the rdp time wasn't affected because the rsp is like it's it's so lopsided in that game so okay so i did that and then you know got some nice uh you know interesting stuff and then you started talking to me about improving rdp time so i added things like the auto batched rendering where if you run the same material twice it'll detect that and then skip the texture loads the second time um and so oh you feel like you're watching college lecture i haven't even started about like oh these are you know this is how the pipelining works and it takes these seven cycles yeah this is still the dumb town version that i can understand because i never looked at microcode yeah um i can talk about that a little bit if you want but um yeah anyway so i added things like that that were supposed to improve rdp time and you get a little bit of rdp time savings then the other thing i guess i should have gone back is when i improved the when i when i rewrote the vertex processing it was for a few reasons i wanted to like clean up all the register stuff i wanted to add new lighting effects but i also wanted to increase the size of the vertex buffer so this is basically a cache in the rsp's memory for recently sort of recently used vertices but it's manually managed you load a bunch of vertices and you you can reuse them and so um i can actually show an example um of uh what the what the difference is in performance so this is a uh this is a mesh uh this is a suzanne monkey let me turn off the light moving here so um this is uh you know taking 7.6 milliseconds to do i mean it's link is behind it so there's a there's a bunch of stuff but this is this is a mesh it's like um about a thousand vertices if i if i look at it and put link off the screen you can see it's about a thousand vertices there's a few vertices for hud and stuff like that but about a thousand vertices and this is using the 32 vertex buffers this is still f3d ex3 but this is using like the model exported with f3d x2 with the 32 vertices and so right now you can see 7.6 milliseconds on rsp time for graphics right if i change this to this version it's 7.4 milliseconds so it's like it's like a uh 7.5 so it's like a 150 i mean something like that 150 microsecond improvement by increasing the vertex buffer size um and this the the amount of improvement that you get depends on how many vertices are shared across triangles that are like reloaded so if you have like 32 vertices you could draw a bunch of triangles and then you have another 32 vertices and you draw a bunch of triangles if any of those like second set are the same as the first set then you've wasted time by reloading them and if you made the buffer larger then it would it would save that time that's the only advantage isn't there also an advantage in just having less comment and like less uh dmas at all yes um it seems to be very small though right because i just tried exporting it with the x3 buffer and if you look at my stream there's basically no measurable difference here so i think what's going on for you but i'll talk about that in a second um well okay i guess i'll answer that now so i don't think you have your scene has a lot of like a lot of connected meshes yeah exactly if you have if you have like those mushrooms right like each of those mushrooms would fit in the vertex like the cap of the mushroom would fit in and so you can maybe like load two mushrooms and draw those two mushrooms and then load another two mushrooms but it's only if there's like a continuous thing that you're loading pieces of it and then like the edge vertices have to be copied that's when it will really help i mean that would be some of that right because like all those actually the uvs are different so maybe not right that's the other thing so split vertices is a is a big problem yeah if the uvs are different or if you're using flat shading and the normals are different um and i don't know if you saw my mesh compiler design doc um casa but it's something that we're planning to try to fix in the future so with the split normals uh sorry with the split uvs um there's a command in ex2 and ex3 which is like overwriting attributes of vertices so you can like load the vertices and then render the triangles with the you know the one uvs and then overwrite the uvs and then render the triangles with the yeah i thought you think that's worth it because isn't that also like a full comment so i guess you save eight bytes of data throughput is that it um you would save eight bytes of data for not reloading the rest of the vertex but you also save the like the processing time for reloading the vertex oh okay like just overwriting the attribute is less time than actually reloading the vertex makes sense yeah and so when you know in your in your case that that rabbit scene is rsp bound so it's not just we oh we care about saving memory traffic all the time it's we care about saving every rsp cycle yeah so to go back to what i was originally saying about like the the x3 performance is i did all those things i made some performance improvements which would help with rdp time i also made some performance improvements which would help with point lighting if you have a huge number of point lights like if you have like seven point lights ex3 will be faster than the x2 but then i gave it to you and you were like hey this is way slower and then i started actually measuring things and then well first of all i found out that your scene was rsp bottlenecked but then what i did is i built this thing called lvp noc so noc is no occlusion plane so that just cuts out the processing time for checking whether every vertex is behind the occlusion plane or not which is just like a feature i added lvp is legacy vertex pipeline so this is porting the f3d x2 vertex processing to f3d x3 now you might ask why isn't it just like oh you just like copy and paste the assembly in because i change i have changed all the register allocation stuff yeah and because lvp still supports 56 vertices in the buffer and their default stuff doesn't support one of the things basically vertices are in ex2 they are hex 28 bytes so five words internally like when you load them it's two words it's hex 10 bytes then when it down to 26 which okay well first of all interesting you're saying a word is eight bytes that's not how i know it i always say word is four bytes oh sorry like dma word right this is a 64-bit console okay in the rsp everything is like like a register okay make sense unit is is 32 bytes but yeah anyway so it's um so it's no longer a multiple of a dma word it's they're all like shifted a little bit because yeah i'm in there and so um the vector instructions in the rsp all the the immediate offsets in a vector instruction for like load or store um let's see if i can i can pull up an example here they're gonna be all different right but you don't actually need four byte alignment or eight byte alignment yeah so if you're doing a quad vector this is load 16 bytes in one cycle um your offsets have to be a multiple of 16 bytes if you're doing a double word vector which is eight bytes your offsets have to be a multiple of eight bytes and so on and so the original vertex processing used these offsets but because all the vertices were a multiple of eight bytes they could do that because mine are a multiple of six bytes to go to the next vertex is not an even number of eight bytes and so i couldn't use those offsets and so i could like their whole code just would not work as is and so um this had to be like rewritten and using the same strategies and then there was some there was also some other things so the upshot of all of that is so then so then i made that and then kaza took it and then it was still like one millisecond slower and so then over the past like two months i have been shaving time off and going through and like counting cycles by hand of ex2 versus ex3 and i won't go through the details of it but it's it's way more than just counting cycles in a in a you know mix assembly for parts that don't have any vector code then it's basically the same i can i can show let's say for command dispatch this is something that i fixed a few weeks ago um it is also interesting to note that for like the last 28 years i was like well the reason the n64 is slow is because of fill rate and memory throughput and now we're at this point and actually it's the rsp well it's because kaza has like optimized the sorry sorry i keep calling you kaza because you said that on one of your videos a year or two ago and now you say k is so what i call you i use whatever sounds better in context it doesn't matter at all okay um yeah so yeah yeah so so it's because you've optimized the rdp so much because that was usually the bottleneck that then you're seeing your rabbit scene is now rsp bound and now that's what has get optimized um yeah so this is command dispatch right this is these are all scalar instructions there's no vector stuff first of all all the stuff in ifs are for like profiling so those all are just not in the base version um so we can skip those and then the only other thing well for scalar code anything that loads to a register other than an arithmetic instruction has two cycles of delay before it's ready so this move from coprocessor zero into register one then i have to like not use register one for two cycles and then i can use it in this cycle um i can use it immediately like this will still work and give me the right results um but it will stall for two cycles yeah for it to be ready so um i had some like stupid things in here um and i just like looked at the x2's version and then sort of copied it but things have changed i'll tell i'll talk about that in a second but so you to count cycles of this you say okay this is one this is two this is not depending on anything this is three this is four this is ready in time you know five six seven eight this is dependent on this that's ready in time so nine the the is ready in time even though you use it next line yes so this is an arithmetic instruction okay makes sense so the results of arithmetic instructions are always available immediately it's only like loads and stores okay and i guess mfc and mtc yeah so those are mfc would be a load right yeah in the vector unit and mtc is a vector load so that is a three cycle penalty rather than a two cycle penalty but i'm skipping the vector stuff for now okay um yeah so this is this is fine because this is arithmetic instruction the do this one two three four five six seven eight nine this is all goes away because it's not profiling this is 10 this is 11 and then after a jump when it lands on the target there is a bubble so i just think of it as like the jump then you have the branch delay slot and then you have one cycle to land on the target instruction so this is 12 cycles right and ex2 this same command dispatch is also 12 cycles but they're a little different you see i am loading a well ultimately loading a um okay so we get a command zero for the for the command shift right shift it by 24 so you get the highest bit the highest byte in register 7 then we load from command mini table which i'll talk about load a byte there shift the byte left by 2 so this is like 256 possibilities it's now yeah that looks like a standard jump table and then well yeah this is not a standard jump table right so if you were doing um nips on the cpu addresses are 32 bit so you would load this byte then you would shift this address sorry you would shift the 7 left by 2 to get a a 4 byte you know how many words in 4 bytes to jump to on the rsp addresses are 16 bits they're actually 12 bits because there's limited imm is is 20 is 40 96 oh so addresses are 12 bits so everything fits in a 16 bits so the way ex2 did it was the command table is just like two bytes for each command handler and so they would take this seven they would shift it left by one then look up in the table and then jump to that register yeah but that took two bytes for every command in the in command table and i needed to optimize it and so what this is doing is this is one byte for every command it is the address of the command divided by four oh and then we we multiply it by four so it's like which word so this is there are 256 possibilities here so you can yeah to like 0 through 10 20 10 20 yeah of bytes out of the 40 96 bytes of the of the imam what that means is that all of the command handlers have to be in the first quarter of imam yeah so it's all reorganized so that everything goes in that memory and then like other like and triangle and stuff are what take up the rest of the memory and so this now i only have to use one byte for every command handler and that cuts the the size of that because i had to like cut it's like 256 comments too right there so you there's 256 like possible range of like where the space is but there's not 256 actual like valid yeah a lot of them probably just lead to the same path Well, like, more than half of them are just nothing. Like, they're just not defined at all. So, 0, this is the table. So, 0 is here at sync. You have, like, oh, I can just show it in here. This is the GBI. So, 0 is no op. Then you have up through B as positive commands. And then you have negative commands down through D5. Oh, they're signed. Yeah, so it's only D5 through 0B. And, like, the rest of it, which is, like, more than half of them, just don't exist. Oh, I see. Sorry, give me one second. Someone... Oh, I don't need to look at that. Okay. Someone said, nothing beats watching what looks like a terribly boring work meeting on a weekend of entertainment. Hey, I promise I'm keeping this pretty high level, not going into all the, you know, scheduling and stuff. So, anyway, I put, like, three weeks or more, maybe a month into this vertex processing loop. Because I thought, okay, that was what was egregiously slow in EX3. You can see F3DX3 without any of this stuff, vertex processing is, like, way slower than on EX2, right? Yeah. Now, look at this, right? So, with no lighting, same number of cycles. With one directional light, it's three cycles faster. And this is, like, per vertex pair when it's loading the vertices. So, I did that. I got it down pretty well. It was almost as fast as EX2 for Kaza. So, in the last few weeks, I spent time on other things. So, I went through triangle draw. Now, I'll talk about how I did a couple of things. The fact that I was able to get this any faster is because of mistakes on the part of Nintendo. Makes sense. This is, like, they should have just done this and it should have just been faster. And then my version would just be, like, one or two cycles slower. But because they had a couple oopsies in there. And so, yeah. So, these are the times for, like, from starting to process a triangle to finding out that the triangle is offscreen and going on to the next thing. And so, like, one cycle faster for EX3. One cycle faster for EX3. This is finding out that the triangle needs to be clipped. One cycle faster for EX3 in both of these cases. Finding out that the triangle is facing the wrong way so we can call it for that reason. Same time. This is a little slower for me, but then Nintendo made it easy. It's 38? Oh my god. Cycles. Yeah. Yeah, I'm surprised it takes 38. I thought it was way less. It's because... So, a couple things. This is... You can't determine whether a triangle is facing forward or backward unless you know that the triangle doesn't need to be clipped. Because if the triangle goes through the camera plane and to behind the camera, the part of the triangle that's behind the camera will effectively have its orientation reversed. Yeah. And so, like, any of that stuff is just garbage if the triangle is going to be clipped. So, you have to check offscreen. Well, you want to check offscreen first. Then you have to check clipping. And then you have to check backface after clipping. Okay. So, if I turn off GCal back, do I get some of these cycles back? You don't want to turn off backface culling. Then it'll draw the triangles that are facing backwards. And then instead of 38 cycles, then it'll be 160 cycles. Okay, but I'm thinking, what about, like, a billboard of the triangle? Oh. No, no. It doesn't, like, skip the check if it's facing the wrong way. Yeah, that's what I needed to know. Yeah, no, it doesn't do that. And then, yeah, actually drawing the triangle, a couple bugs, a couple perf bugs in the original. And that's why this is a little faster. So, this is what you're using now. And then the thing I just spent, like, the last two days on was transforming light directions. So, this is something I didn't have to use to deal with in EX3 because it does things in world space. But in EX2, whenever you load a matrix or you change the lights. So, in your scene where you have, like, superfluous constantly resetting the lights to the same thing. Every one of those times, it clobbers this and has to recompute it. Both on EX2 and EX3. This, then, the next time it runs vertices, it has to recompute the matrix if the matrix changed. And then recompute the light directions. So, it is transforming all of the lights into model space. So, like, if you're rendering Mario, you get to Mario's hand. It transforms, like, it redoes all of the lighting into the space of Mario's hand. So, then when it's loading the vertices, it doesn't have to do any more transformations for the lights. The thing is that actually loading the vertices, like, this is all happening between starting to load the vertices and waiting for the vertex load to finish. So, Nintendo probably thought that this was just, like, oh, it's hiding in that amount of time. But if you're loading 32 vertices, that's nominally 64 cycles. There's a lot of overhead. So, maybe 100 cycles or so. But this is just, like, taking more time than that just for the vertex transformation. And so, in EX2, this is just purely overhead. And so, I just cut a bunch of time off of that. Oh, was it just mistakes that made this take so long? They just didn't. They wrote it with, like, a little bit of optimization, but not a ton of optimization. Oh, so they just didn't care. They just didn't care because they thought, oh, well, this is once per vertex load. Not, like, per vertex, but per load instruction. And then, like, it's just, like, it should be hidden in the vertex load time. All right, that's good. Ideally, I wouldn't have to spend this time at all, right? Because I just load the light once. It's just not what I do right now. So, if you're doing a scene, if you load the lights once at the beginning of the whole scene, and then you never change the lights and you never change the transformation matrix, then it never has to do this. But for any skeletal mesh, every bone, it has to redo this. And any material that changes the lighting, even if it changes the lighting to the same thing, it has to redo this. Makes sense. So, it's per matrix, basically, ideally. Yeah, it's per either matrix change or lighting change. Yeah, but ideally, there would be no lighting change. Yeah, I mean, with OOT, the way they would do it without point lighting is they would set up the lights once before every object to, like, make fake directional lights. But then, usually, within the object, you have at least one transformation matrix, so there's no extra penalty for that. Yeah. Yeah. So, part of the reason that this is long is that, for both of them, is that when we have one directional light, it's not actually one directional light. It's three directional lights because you have the two look at directions. So, even if you're not using text gen, it has to transform the look at directions. And this is a, like, GBI sort of, not a GBI problem, but, like, a, if you didn't do it this way, it would break guarantees on the way the whole, like, material system works. Basically, you load your, like, you load your mesh, you know, you do Mario's hand or whatever, or let's say it's Link, right, because you have Link's hand and sword are the same object. So, you, you know, you do load the transformation matrix, you load the part that is his hand, which doesn't use text gen. If we made it say, oh, there's no text gen enabled, and so we're not going to transform the text gen directions, then they're garbage. You render that, now you change materials to a material that has text gen, and the text gen info is garbage, and then you render that, and then it's garbage. So, we have to pay the penalty for every material, or, like, for every vertex load, every time this has to be done, for transforming those, even though they're rarely used. Damn. But, yeah, in order to fix that, you'd have to say that you could not, like, you'd have to, like, manually tell it that things were changed before you used a material that had text gen enabled, or, like, track it as a separate thing. Kind of related to that, do you think there would be additional performance gains I could have from just removing the support for point lights? Because I use fake directional lights right now. Um, EX3, sorry, LVP-NOC does not have point lights at all. Oh, okay. So, that's already done. That's already, already done. Good. Um, yeah, so, this is, like, what I've done, the performance looked good to you, but I do want to, I did want to try a couple of things. It looked like you were not drawing the extra counters for EX3 in your comparison. So, I thought, because at first I thought it was like, oh, well, of course, he's drawing the extra counters because EX3 has a performance counter. So, he's drawing the extra counters that's taking time, that's counting against EX3, but not against EX2. Do you know what I mean? Yeah, I do have them on a separate page here. Oh, but it's on a separate page. Oh, so you switch on your stream? Yep. So, normally it doesn't show them? Yeah, I can just go through them. Okay, so you were using, that's what you compared on, okay. Yeah. Yeah, that should be fine. Um, so, that's not an issue. I wanted to give you a version where the hints and the auto-batching are broken and see what the performance difference is in this rabbit scene. All right. Because then that will tell you how much that is saving. And then the next one of, like, computing on paper how much slower it should be, that doesn't matter because now it's faster. So, let's see here. So, breaking the hints. So, that is here. And this is a, this is an instruction that's basically pulling the hint out of the command and then initializing this. And so, I'm just going to replace this with I input buffer pause zero. So, then that should be basically forcing everything to have a hint of zero. I'm pretty sure we already have everything have a hint of zero right now. I thought you changed the GBI to have everything have a hint of two. I undid that. That was just temporary for a second. Oh, so these performance improvements are not with the gain of 300 microseconds of the hints. Yeah, at least I'm pretty sure. So, you're going to get an extra 300 microseconds. Yeah. If you enable the hints. Well, okay. So, for chat, what this is about is a display list has, like, a normal program, can have calls, it can have jumps, and it can have returns. And in EX2 and all the Nintendo microcodes, when you do a call or jump or return, well, whenever you need to load commands for, like, display list commands from memory, from, you know, DRAM into the RSP's internal DMEM memory, there's a buffer for them. And so, the buffer is 21 commands. And in, you know, all the vanilla microcodes, when you do any call or return, basically, when you move the program counter, it just fills up the whole buffer. It loads all 21 commands. And in our, like, in a lot of display lists, especially, like, stuff emitted from Fast64 without any kind of inlining or whatever. Yeah. So, with Mapbleed, that's a Mario 64 thing. You can just have all of your display lists, like, one after another. But in OOT, that's not a thing. So, that's basically the top level OOT display list will just be, like, call this, call this, call this, call this. And so, every one of those calls, when it returns, it loads 21 commands. It executes one command and then just ditches the rest of it and goes somewhere else. And so, that's super inefficient. And so, I added this option to put hints into the call, branch, and return commands. And those hints will basically tell it how many commands to load the first time it loads the buffer again. And so, Kasa is setting this to globally, when it returns, it always loads two commands. And you came up with that because it was, like, normally you would have just a matrix and then a call. Is that right? Yeah, basically. Either a matrix and a call or, like, a material and then another call. That's, like, 90% of the time, that's what you get. Right now, I took a measurement of DL and FDL in the X3 counters. And I just set the hints hard-coded to two. And I'm going to do a comparison now. So, the way this is supposed to be used is that the exporter will just, like, decide that I can't tell what that number is because it's corrupted. I feel like maybe the DL and FDL display is not part of this profiler. But the E2E is down, like, 200 microseconds. Okay, I mean, that's good. Yeah, the profiler, so the version I gave you is default. And default does not have those. Yeah, that's probably the reason. Those are, like, counters of number of rectangles and number of vertices or something like that. Yeah. So, I have to give you... I mean, I can do that right now if you want. Yeah, it's not important. What matters is E2E anyway. Yeah. It seems to be sliding down, actually, maybe, like, 100, 250, maybe 200. Hard to tell. So, the way this is intended to be used is that, like, when you export the display list, the program that's exporting them would just, like, count how many things are in the target and just set the hint to the correct number. But what Kasa is doing is just globally setting it to two and just assuming, you know, hoping that more of the time that will be more optimal. And, you know, sometimes it'll be worse and sometimes it'll be better. And if it's better enough, then we get a perf game. Yeah. So, yeah, that's what you did. And I want to try, then, with the hints, that's not needed. But then I want to try the auto-batched rendering and see how much that will save us. So, this is... Oh, this one I just had did not have auto-batched rendering yet? No, you have it. Okay. So, I want to break it and see how much the RDP time goes up. Okay. So, this is in... where is it? Oh, I moved that. I'm a little worried that without the auto-batching, we're going to have a higher E2E. That's the feeling I have. Yeah, I mean, that's the point, right? It's an optimization. So, if we break it, then... Yeah, but also RSP is going to be higher now, I think. Worse than an X2. Maybe. We'll see. Before I actually change that, just for the record, look at this. Small RDP command. F3D X2, 14 cycles. LVP and OC, 5. That's pretty crazy. So, this is like all of your load texture, you know. Yeah. Well, not the texture, because the texture actually has to check this. But for all of the other stuff of like set tile size, you know, sync, any of the miscellaneous, you know, set other modes, set combiner, whatever. And the reason for that is that they had a bunch of like... It branches here to write the value to the RDP. Then it branches somewhere else to check if the buffer is full. Then it branches somewhere else to load the next, you know, continue to the next command. I just reorganized it so that they're all in a row. And so, it just like writes it. It will branch away if it's full, but then immediately starts loading the next instruction. So, where is this? It was here. Yeah. So, this is RDP command handler. Store the upper, you know, store one, word one. Store word zero. Increment the buffer. Check if it's full. Branch away if it's full. If otherwise, immediately run the next command. And that's the five cycles. So, load commands handler. Load material call mode. And if it's less than zero, run the next command. So, I am going to just comment this out or make it a NOP to make sure that anything else doesn't change. So, this will just always run the load command. So, let me file that for you. I guess material call mode is set whenever the texture is set. So, the way this works is actually not here. It is when it runs a set image.  Okay. That's what I thought. Yeah. So, what it does is it maintains there's three possible states for this. It can be zero, one, or negative one. And zero is you're not in a material. One is you're in a material the first time. And negative one is you're in a material the second time. So, it's like a finite state machine. So, if you're not in a material and then you run a set image handler, it goes to being in a material. And the way it counts ending a material is any of the, like, branch or jump or anything or return. Or vertices or triangles or texture rectangle. And that ends the material. Right? And what it does is it stores the actual physical address of the material. It's not storing the image address or the texture address. It's storing, like, where was the address the material started at. And so, when you, you know, you start your material with a, you know, load image. Then you set the image. Then you load image. Maybe you load multiple images. Then you draw your triangles. Then at some point you jump back into the material again. It hits that same point. It says we're starting material again. But it's at the same address. And so, it sets it to negative one. And then it will skip all of your loads after that. So, it works with multiple textures that way. Yeah. So, it works with two, up to two CI4 textures. So, that's two texture loads and two, like, loads of the index. Makes sense. So, which is better than actually, like, checking the, than, like, checking the texture addresses. Although, that does mean if I have two different materials with the same texture, it's not going to match. That is correct. You would have to, like, but I think hopefully that's how you have your scene already. Yeah. Or if you're not running it in the right order, then it's not going to match it anyway. Yeah. It's just important to keep in mind. Here's another version. This is with that broken. And we'll see how much your time goes up. All right, let's see. It's gonna take a little bit. Man, the Summer Card makes my workflow so much faster. It's so good.  Yeah. I've been using it for the last couple of months, and it has been so much better. I did have a decently good workflow. I got a really high-speed SD card and a high-speed SD card reader, and so I just have it like off-camera this side, and the N64 is off-camera on this side, and just swap it over. But yeah, it's still faster with Summer Card. It's also just nicer. All right. So this is an unlimited FPS mode. This seems significantly worse. Well, E2E doesn't seem to be increased at all, actually. R2P 23, 24, roughly. What was it before? I actually don't remember. I don't remember exactly. I feel like it was more before, but maybe I'm crazy. So I don't know. If you don't have, let's say, those rabbits, this depends on you drawing something twice that has the same material, and it skips the texture load. So if that never happens, because your scene isn't, that's not happening in the scene, and if it's not happening in any of your actors, if you're already batching the coins or whatever, it might not do very much. And the coins are batched. The rabbits are not, and the Goombas are not. Do you know if the text counter here is accurate? Yeah, yeah, that's a RDP counter, so that would never be not accurate. It was 2.2 before, and now it's like 5 point something. There's no way it's that much worse. I think it might be. Let me look at the bunny geo. You might think this is funny. Beta Sigma Omega subscribes and says that they are lost. Thank you, Beta. You came into a stream about extremely nerdy Mario 64 stuff, and you're getting extremely nerdy stuff. Yeah, yeah, sorry, look at this. This is where the difference is from. Oh, so you're loading the same material over and over. It's 14 times. 14 times. Okay, well, there you go. But there's no way. You've got to look at the overall RDP time again, because it shouldn't. That 5 milliseconds, that looks kind of wrong to me. No, that's just texture. Right, the 5 milliseconds for texture looks wrong to me, because OOT is usually 3 or 4. Yeah, but I load the same texture 14 times for every bunny. There's like 6 bunnies here. That's 84 texture loads. A texture load is 30 microseconds. I'd like to see the old version. Can you just pull up the EX2 version? Just like the video of it? Because this should be the same behavior as EX2 as far as the texture. I didn't measure texture. But I can pull up this one here and look at the RDP. 25 point something. Without texture batching, we had 24 exactly, pretty much. 24 exactly. Yeah, it's the same. Okay, so then we've got to see how much. Then we've got to go back to the other EX3 and see how much it saves. And RDP is, in yours, is down 400 microseconds, roughly. Oh, you're just looking at the old version. Wait, are you talking about? Sorry, I got confused. Without material auto-batching and just your new RSP features, the RSP is down 200 to 300 microseconds. Oh, just from the memory traffic savings? Yeah, and from your cycle savings, I would imagine. Yeah, I guess. So, yeah, that would be from, because it's RSP bound, it would be like it gets to the RDP things earlier. Okay, well, great then. And then I still want to see how much it benefits. I'm working on it. Oh, do you have the old version? Yep, I just downloaded it. I'm testing it right now. No rush. Sorry, I was a little confused. Don't worry. I think that's auto-batching in F3DX3. Yeah, look at this, text is 2.2. It's literally a 3 millisecond difference. Well, you got some rabbit problems. But RDP is higher now. Oh, wait, this is unlimited FPS. Yeah, okay, it's 1.4 milliseconds down. I guess you have big, big rabbit problems. Yeah, the thing is, usually I manually batch this, because for 64 I can't do it right. I guess I have to look into that. So, how many materials are there on each rabbit? Let me look. Well, I mean, now with EX3 you don't have to optimize that code. I might still have to, because if you look at this... Wait, this is all one. Okay, maybe I don't have to. Yeah, I was going to say, this is only going to work if the whole rabbit is one material. Yeah, I must have exported the wrong one or something. Because if you look at this, there's... These are different ones. Wait, wait, wait. Ah, rabbit new. Okay, this is the real bunny. Yeah, okay. Well, so the thing is, EX3 is not going to help you if it draws all of one rabbit and then all of the next rabbit and there's multiple materials. It's not going to help. Let's say 3 milliseconds. Well, it's not the rabbit. It's something else. No, it is the rabbit as well. Because some of these are still shared. If you see the Moose Face material here, you see how there's three bones here that all use the material? Oh, you're saying it is reloading the material for each limb. Exactly. Okay, so OOT, I implemented that kind of map bleeding and that does work in OOT. So that would not be happening in OOT. But in OOT, we don't have your scene-style map bleeding. This whole scene is just one DL. The scene is still just a bunch of calls. So with the Mesh Compiler, that will fix all of this and you'll just have the nice thing for all of your... Wait, how's the Mesh Compiler going to fix this? Leela is suffering because map bleed is off. Okay, Leela, I'll turn the map bleed on for you. That's just going to make the display less... Actually, no. If I turn map bleed on, then it's just going to inline all the calls and the material is no longer going to be the same thing and X3 can't batch it anymore. It's going to make it worse. But it will just save the calls that X3 was automatically saving. No, it won't. Like, it won't? No. I mean, I can just export this one. No, but if it inlines them, it doesn't just inline them. It inlines them and then it notices that it's the same thing twice and it skips it. Right? I'm not 100% sure about that. Map bleeding does not just mean inlining. Map bleeding means it writes the difference between the old material and the new material. And so if there's no difference, it will write nothing. Yes, but I don't think it works between armature parts and Mario 64 yet. Oh, okay. I think you might, you know, if you're doing engine changes, you might want to change the whole way armatures work to be more like OOT. Yeah, if you look at this, here's confirmation. It's loading this texture twice in a row even though it's on the same mesh. So map bleeding makes this worse. Yeah, I know. I thought about this before. I agree. Update to main maybe? Oh my god, Leela. Fine. No, no, no. Don't update to main. Leave your bunnies unoptimized and let F3DX3 save you. That's the right approach here. No, I don't know. This is... This should all be dealt with eventually. Installment? I hit update, Leela. What do you want? Either way, I think my real fix is here to make the bunny work with one texture. So I'm guessing the way OOT does it is that it can ask one dispelless node for each part of the thing? The way OOT does it is there is no... Okay, so for skinned meshes, which means you have triangles that go across different bones, which is normally how it is. There is a region of memory that is allocated that has all of the matrices for all of the limbs. And then in the display list, it's still separate display lists at some level for each of the limbs, and there is a callback between them in case you want to modify the limbs or have the character holding an object or whatever. For the most part, there is no geolayout struct or anything like that. It starts by putting all of the matrices in this thing. When it gets into a limb, normally it just loads that limb's matrix and then draws some stuff. But if it has vertices from a previous limb, it loads my matrix, loads some vertices, loads a different limb's matrix, loads some vertices, loads another limb's matrix, loads some vertices, and then draws triangles. So you can have arbitrary connected vertices between arbitrary limbs. So then what you can do is you have all the matrices, you upload them at the beginning, and then you can just like, if you're not drawing anything in between, if you're not using those callbacks, you would make your whole skeleton be one display list again that's all inline. And then it just like, when it needs to, it'll load a mat, it'll load whichever mat it wants out of that structure and load some vertices, and then it can leave stuff in the cache and so on. That's what the ultimate version of this would do with the material compiler thing. I was thinking maybe in the mesh comments itself, it would link a material and then would add it to different buffers and then the buffers would be batched like that. I think that could work. It's kind of how I handled some stuff. That's kind of how rdpm also handles right now. That's like vanilla Mario 64 behavior. You mean using segments, or you mean just like manually calling another Basically, I have a buffer, and I would have a buffer per material. And whenever I want to draw geometry with this material, I would attach it to this buffer to make sure all geometry with a certain material renders in the same row. Like in a row. And I would never have to switch the material. Yeah, basically that's what it would be. Yeah. You could do that for OOT also, like if you had multiple rabbits and you had to have multiple materials you could like manually draw the ear of every rabbit and then the head of every rabbit and so forth. Anyway, this is for the future of Yeah. Honestly, I think for me the easiest would be to just make the whole rabbit one thing, one material. I think that's the way to handle this. You should be able to have a texture that has even if it's like the maximum size texture Yeah. It's only slightly lower res, but it works. It wouldn't work for skin meshes, Leela, if you're trying to leave vertices in the vertex buffer. But it would work for skin meshes using the OOT method where when you go to the next, like, you know, if you did upper arm and now you're going to lower arm. Let me get this on camera. If you did upper arm and you're going to lower arm and you need to share these vertices, when it does lower arm, it just reloads the matrix for upper arm, reloads these vertices, then loads the matrix for lower arm and then loads the rest of the vertices. So that would still work. Yeah, but that's duplicating vertices and the matrix, so I don't like that. Yeah, though it's pick your poison, right? It's either you do that or you duplicate the materials. So, yeah, if you can fit everything in one material, then great. Yeah, I prefer that solution. Either way, Leela, I checked the batching and it now batches and it's still the same because x3 batching took care of this before, but I guess it's less RSP comments now, so that's nice. You could also try that on on EX2 and see what it looks like on EX2, but not necessarily right at the moment. Yeah, it's just going to be slightly worse because it doesn't do the Goombas. That's what I imagine. Yeah. So one other thing. Yeah, so Leela is trying to tell you that there's a difference between main and release, that if you download a Fast64 version that's a released version that's months old, whereas you have to actually download the current repo state in order to get main. Yeah, but I don't see what the difference could be, so I don't want to deal with that. Well, if you have the batching and the batching is not duplicating the textures anymore, then you're fine.  Changes and things happening. Yes, yes, this one. So let's there's another thing I want to do in this stream, but we should do that towards the end, which is some different EX2 stuff. I want to compare the EX2 version that you've been using, which has the overlays removed, so it's like both overlays are always there, with the actual base EX2, because that's what I have to compare to when I'm doing EX3. That's EX2 optimized, and so it's like I've already gotten EX3 now to be faster, but this whole time I was trying to beat not beat EX3, but beat EX3  And then, oh yeah, I guess we don't have to do that part either. The thing I want to do now, you have GBI changes that makes it hard for you to merge my GBI into yours, and my GBI is going to change a little bit in the future, also because I have a when I do the Z fighting changes with decals, that will also make a, I'm going to take out the old version that I added to X3 for fixing decals. So there would definitely need to be one other, oh what happened to your lighting? Yeah, I still need to fix the lighting for X3. Wasn't there some lighting changes required for X3? I have not looked into that yet. Sorry, what are you, like it was obviously working just a minute ago. It's working on N64, it's not working on here, because it's loading X2. Oh, oh, okay. So you mean you have you have like the EX2 microcode, but EX3 game? This is EX3 GBI running on the game emulating X2. Right, okay. So yeah, that's not going to work. In fact, I'm surprised that the emulator is not crashing. Oh, I mean you purposely designed EX3 to be like this, right? Do you mean like why are the lighting commands different? No, I'm saying you on purpose designed EX3 to work in a way that an emulator running EX2 is still going to render the correct output. Yes, if you have your game code like manually do the EX2 lighting commands instead of the EX3 lighting Yeah, I still need to do that part. Yeah, so that's not going to Right, okay. I realize we're on the same page. So for chat, what we were talking about is EX3 and EX3 is binary backwards compatible with EX2 for everything except for lighting related commands and some sort of very similar related stuff. And hi, we have a raid from rad slash live So one viewer raids. He raided after watching himself. Okay. And so if you have a game which does not embed lighting commands in static display lists, which is OOT and which is most of RTYI except Kaza still has some materials in his scenes that have lighting enabled for some reason. But once that's gotten rid of and all the lighting is actually like handled live in actual code then all of the static display lists in random objects and scenes are binary backwards compatible. What is not backwards compatible is the lighting commands and so you need to have your game code actually have logic that says if we're running in an emulator use the send a EX2 lighting command to the RSP and otherwise send a EX3 lighting command to the RSP. Oh, how did you do that effect, Kaza? Oh, this one here? With the things fading into view as they get close. That's cool, isn't it? Um it's threshold alpha with combiner clamping so when i'm like here this has like an alpha value of like 150 which clamps down to just 100 and then when i'm away it like goes down to like zero right and then there's like a pattern to it on top that's getting multiplied so the pattern like alternates between just over the threshold and just under the threshold and like a hexagonal one that is like as another texture yeah it's a multi-texture here one is the dither pattern and the other is the actual visible texture that's really cool so are you manually manipulating the alpha on the different vertices then yes uh okay i thought this was some like um level putting like the level of detail cc output into the uh you know through into the alpha that would probably work uh well but then it would look less good that are yeah it wouldn't be like the things that are farther away from mario yeah um anyway where was i what was i talking about before that um fighting oh yeah yeah so um you can make a game which is what kaza is trying to do where it uses ex3 tells the emulator it's using ex2 and it works on 64 because it's just using x3 everything's fine and it also works on emulator because all the static display lists are backwards you actually have the game code itself picking to send the ex2 commands for the ex3 commands based on whether this is um and so kaza hasn't done that last piece yet oh and there's one more piece is that the 56 vertices in the buffer because the hle is so bad it just supports 64 vertices in the buffer for all microcodes and so you can just use ex3 56 vertices and it just works um which is great news for us the thing is backed and that's why it works yeah it is a feature so um yeah so i want to see if we can fix your texture corruption on the uh the uh text and also because i figured that's probably a gbi problem and then also merge any that you've made to the gbi into my gbi so that you can just like update to mine in the future all right um so do you have like more render modes and stuff that are not like in the default gbi yeah i have a lot of costs actually i don't have that many custom random modes but i have a little bit of that sorry i'm fixing i'm making the bunny work go ahead and fix the rabbit actually i'm i'm gonna take a very short break here so you get some time to fix the right all right see you in a sec see ya what sarin is busy doing that i'm gonna reduce the materials on the bunny so that the batching works better hello siak an update of us and of course i don't want to do that right now enough i'm doing work so how do we best make this one work i can't see it yeah works well enough i got rid of a material this won't save anything by the way mad bleed handles textures across materials okay Lilaa whatever you say i'm just gonna ignore that and do what i know is right i'm stupid you ignore that yeah don't worry i was gonna and then i just need to make this texture part of it and then we have everything working so i'm just gonna ignore that and do what i know is right that's gonna be a little more difficult hello head crack dude with the findings from today i could make a banger video going everyone was wrong about the the rdp but rather the rsp all along if you were actually to be optimized enough are you directors running an emulator isn't me supposed to run exactly like console it's supposed to but it doesn't and i mean if it was to run exactly like console then we wouldn't need to check for emulator so how do i best make this material works oh this is a bit of an issue i'm back welcome back look what i did to the bunny i used this whiskers to make his paws and now he's one material less and then i'm almost done all right uh you said you wanted to do the light next uh what did you say uh what i said but you're free this is your stream so you could do whatever you want uh oh wait gbi merging touches and the gbi merging yeah so i think i if i had to guess so you do remember because we just tried this briefly um when i sent you the version that had um material culling the text textures were still broken right yeah okay so it's not a material culling bug in the microcode um so i'm guessing it is a gbi problem um like i remember you talking about and there was some discussion a couple months ago about um never using prims uh pipe sinks and only using tile sinks instead yeah are you using that um it's not those things that's the normal that's the normal ex3 stuff but it's like the definition of the pipe sink yeah i'm trying to find this it's at the it's at the very end of the whole file no i'm not using that here you're not because there there is a definition of the sinks at the very end of the file just just scroll down to the last the last last word oh wait i am yeah so the definition of pipe is going to fix this tile sink right um there's a um defining pipe sink to pipe sink is not going to help you yeah i noticed you have to actually define it to the the the thing like what looks above where it has the dp no param with tile sink you got to copy those and make it pipe sink and the same thing for the dynamic one also if you don't mind the dynamic one you mean the um gssdp yeah yeah both of them you can you can just copy the copy the tile sync one above wait what oh that's right sorry i was looking for this static and dynamic one it's the one yeah then then just copy the tile sync two above that yeah i get you yeah yeah yeah you think we should upload this whole x3 talk it's like a separate video if you ever want to reference it in the future if you want to um probably not on your main channel no definitely not on the main channel just like if i ever talk about x3 i can just link the video and then people have a rough idea sure yeah if you'd like that rebuilt everything you didn't make clean because this is like changing every part i did not make a make clean but i think it rebuilt everything but i can try again okay i'm a little paranoid with that kind of thing yeah it makes sense i have been bitten by that before as well so  Yeah, it's not that No, it's still broken. Yeah Hmm Okay, so it's interesting that it's always broken the same way and let's See if I can So s is broken Some of the like it's not dependent on the number. Sometimes the same number shows up. Sometimes it doesn't Oh, really? Yeah Huh I Thought it was like a certain portion of the texture was getting corrupted how I'm pretty sure we can find every number here I don't see a free actually Looking for free Hmm Let me take a look at Are you using the um Yeah, can you can you because I know you took the oot Um, like text drawer thing and then ported it and so I'd like to If you wouldn't mind if we could look at the code That is drawing the text Um, because if there's If it's the textures getting corrupted, that's one thing But if it's like the actual live drawing of it that's getting corrupted, that's a that would be a different thing You know what? I mean? Like if it's the texture load got corrupted, that's the load for the whole font That's that's that would be one thing but if it's like every single time it draws a number Then there's a chance it gets corrupted. That's like a different that would be like a different thing Yeah, i'm Yeah, it looks like there's no free here There's a four there's a five there's a six I don't see the seven anywhere but like for the letters. It's always the same letters that are That are corrupted right like rsp The r and the gfx rdp are the same and then the s is gone um Yeah, I mean those look like they just look like there's another texture You know something else some other random texture getting interpreted by in this format. Yeah, I think you're right Yeah, um so I can pull up on my side. It's a little easier for me to for me to see is the code But I think you've changed the code. So that's what i'm that's what I was curious is like looking at the the text rendering code and seeing if we can Like maybe see what what happens right after the texture is loaded, um I'm trying to find the code here. This is the um The the system that draws the text not the actual profiler itself Yeah so like I want to look at the the The definition of graphics print printed up, right? Yeah, I got you, okay, so then vprintf sprintf whatever then we have a um at some point Okay, so it would be earlier in this there is the giant wall of at the top of your file There is the font is a giant a giant array So can you look at the the name of that and then find where the font data is? loaded Okay, so we have a Yeah, so just loading the font once yeah, and then it's loading the lookup table um And do you want to just like do me a favor and put in a just like an extra prim, uh, sorry pipe sync between the like before and after and then after that command just like sprinkle them between each of these commands to um To see if it fix it Yeah You need a a just a gdp pipe sync not the gs one Yeah, you need you do not the not the s What you have an s I started copying it from the file and then can you put that before sorry, can you put it between the Load texture block 4-bit and the load tlut also just like between every command just to you know, maximize the Yeah, it makes sense. Oh wait, this isn't the only This isn't the only thing there because there's this then there's a multi-tile load below that Yeah, that did not fix the issue anyway Okay, so you want more here so wait a minute so so wait a second so after that There's the the reloading the the font reloading the texture lookup table. Then there's tile size. Okay, great Then there's set color then there's another Load multi-tile and load tlut. Can you just comment out this second from line 164? Just like starting there comment that out to the end of the function Up to the end of the function. Yeah, because the next thing is tile sizes for Yeah, I never looked at what this does it's Rainbow, but I don't know what it's doing there I copied this from your repo I yes you did and uh, I am not the only person who works on that repo. So well then fix the entire issue Well then um Let me look at the git blame for the rainbow thing Um, well you can you can just leave that off. I mean for to solve your problem. Just yeah, just get rid of that But how did that only break an x3? That's a little concerning, isn't it? That is that is concerning. Um Let me let me pull up that code on my end because it looks like you didn't change that so  Leela are you are you the person who added rainbow? It's not concerning stop looking at it It was one of these, uh, yeah, of course it was So Well, then i'm just gonna delete this because this is useless for me Yeah, uh, if you don't it's that was for making text that like cycles through rainbow colors but I Don't know why it's loading another Yeah, I don't know what the deal with that was Huh, I will I will check on that after after the stream and possibly put in a pr2 I have to figure out what's going on Yeah, that's I didn't actually think it was you leela If it might have been real no Um rainbow data There's a dp load tlut 16. Oh, no, that's 16 right now, that's right So Okay, well we solved that problem, um, I will look at this after stream, um, do you want to um Like merge gbi things so that you can more easily Uh Uh, yeah, if you have any good gbi changes, I like them Yeah, so I what I mean is can you give me your gbi changes so that I can put them into the f3dx3 official version and then When you when there are future f3dx3 versions, um, then you can just directly use that well, I don't think my changes should make it the official version because Oh my changes kind of just disable nth color Because fast 64 keeps resetting this and also lights one because fast 64 keeps resetting this Oh, um, yeah, we don't want those changes. Yeah You definitely do not want them lights one It's you disabled lights one. What do you mean? I believe Leaf somewhere oh oh that means that all of your materials that have that lights command aren't actually happening yeah i think they're just new ups oh yeah here yeah the dp no op right so yeah yeah i don't i don't want those two changes um but um you know actually if this if this will things easier for you um i could put a like ifn def kaza bs and then um you know change those um but no i mean like render modes or like whatever else is just like miscellaneous i wanted to add a define for the um turning off the changing the the pipe sinks to tile sinks oh there's also this define here disabling anti-aliasing that's actually a useful one okay um and is that um let's see so then oh yeah so then you've you changed it to um oh yeah i can just define them to be zero instead of instead of having to do that um stuff with the or um and then the read def is only in commands that have because you would still need to do it for like transparency so you can't just like disable it entirely it would have to be for only certain commands yeah okay can you actually just send me your gbi.h and i can do a diff on my own sure if there's no um secret kaza stuff in there no my repo is not that private i mean are you not already in it no oh why would i have access to your game i don't know i added a bunch of people whenever someone offered their help i usually just added them to the repo well i'm happy to be added if you want i uh yeah i can add you but uh yeah all right here's the gbi let me just add you to the github then so your name on git is just sorin yep oh shit it's asking for a passkey ace do you fuck with geometry dash you know case versus github i'm good on github now all right you're invited thank you i will check that later let's see here yes nafari i'm streaming on both youtube and twitch it's just that i'm that's why i'm not as responsive to chat as usual so yeah this is a fun thing to test with chat there used to be one drop in this level to 28 fps i wonder if this is fixed with x3 uh it's not that's fine we can live with this i'm i am guessing that that is uh already oh wait anti-aliasing was on the whole time we tested this okay but was it on for ex2 also yeah okay well that's fine yeah but that means performance is a lot better than i thought it would be well yeah but i mean it's just the relative performance yes but it's you know still nice for me to know my game actually runs a lot better than i thought yes this also should mean that any rsp bottleneck now should be a lot more relevant so yeah there's still around 800 millisecond microseconds difference between rsp and rdp hmm do you think this is still an rsp bottleneck yeah absolutely okay um you can check by looking at the rdp um command empty counter if you look at the rdp counters you don't have it on screen right now which one's that so not command the slash cm that's the amount of time the rdp was idle because there were no commands so the amount of time rdp had to wait for rsp similarly the fifo the 2.7 fifo uh the orange is the amount of time the the fifo was full since the rsp had to wait for rdp so the rdp is waiting for the rsp for 1.5 milliseconds presumably early in processing and the sp is waiting for the rdp 2.7 milliseconds presumably late in processing makes sense yeah so that's if there's any like non-trivial amount of that slash cm then that means it's rsp bound at least sometimes make sense yep yep i get it and yeah you would normally expect like you know more milliseconds of difference if it was but yeah why don't you go to that spot where it was um dropping the frame rate and see if it's still above 30 oh we got almost three milliseconds cm here more than three and 7.8 fifo now it's almost it's a 28 to 29 now right instead of yeah you you might get it up to 30 if you turn off the counters now if you just have your fps number hey oh i saw 29 yeah yeah it's basically perfect 30 now you have some blend problems on your wall yeah i'm not quite sure what this is it's fixable i'm sure yeah i mean you have a some settings in your render mode are wrong yeah i think this is the coverage this alpha setting i'm doing the diff here oh that's uh some interesting graphics there yeah that's also a bug that i'm sure i can fix and you have animation did i not show the new animation yet huh what what's that sorry oh you like weird lighting stuff that looks kind of cel-shaded where do you see that oh on your in your select course thing where with all the pipes the the lighting on the on the wall was looks cel-shaded yeah so rotate yeah you see how there's like those the lighting that is in steps is that not showing on your screen and only on the stream no i see it um i don't know what the fuck that is that's just the bugging out text that's the floor just stretched that is so weird there must be some kind of weird bug but i think that was there in x2 already yeah not like it matters i would also recommend a ceiling at some point nah you can live without one for now oh there's a lot of changes because um there's a lot of documentation um added in mine and a lot of little changes i'm gonna have to go through this off stream okay and find find the actual differences um well i think that's basically what i have on my list given that it's now faster for you um are you or is it is it official that you're gonna use ex3 oh yeah for sure i'm just gonna add the lighting support which i'm probably gonna do later today for emulator hopefully i can do that with self-modifying code so i don't have to shit up my eye cache and then i think we're all good yeah awesome i'm uh excited to see my name in the credits of the best nintendo 64 game hopefully it will be we'll see what the people say once it's out yeah or at least best technologically i'm not gonna put this above oot um what overall yeah sorry i'm surprised to prefer oot over majora's mask so majora's mask here's my hot take on majora's majora's mask is the only zelda game that breath of the wild did not make obsolete so oot is you know for for modern audiences oot is as lived it's uh you know it's it's aged and now yeah i recommend that as somebody's first zelda game but majora's mask is still bringing something to the table that nintendo has never done again that's true but you know one of those games is like critically important to my life and the other is just a really good game so that makes sense i also beat oot like five six times before i was age 10 nice sorry about that i have to move my car in a few minutes all right anyway is this a good time to to call it yeah we have everything done i'm just gonna finish the lighting off stream i think this is a good point to end the stream yeah awesome um i will hopefully have the z fighting decal thing uh fixed in the next couple of weeks all right another version for you and then after that i want to um so i have like this whole time you've been using lvp noc no occlusion plane right yeah yeah um you can use the occlusion planes version but it's going to like go back to my like pre-optimization version of the vertex processing so it's going to be unnecessarily slow so i want to like redo that now with the latest round of and so that do you think the do you think the occlusion plane version will be faster on the rsp and my senior i was thinking um you know where the bridges below that that's why i was going to put the occlusion plane so it would include all the stumps so a few vertices would be less but others more when there is stuff that is behind the occlusion plane like when the occlusion plane is actually doing useful work then it'll pretty much always be faster to use the occlusion plane version um like you'd have to have such a tiny amount of area that is covered by the occlusion plane that it would actually be slower to do the extra processing for the occlusion plane do you have like a percentage it's so dependent on like where you put it and everything in the scene so if we look at purely rsp do you have like a percentage of how many right now the performance difference is here um right now this is like 54 versus 81 cycles but this is pre-optimization that's the point yeah i've improved this this is probably going to go down to like 70 or something um and then so that you can compute okay if you have 6 000 vertices in your scene and it takes an extra what would be that be like 15 16 cycles so like 6 000 vertices times 16 cycles is 96 000 cycles which is um like 150 microseconds or so right because if you divide by 62 500 that's oh no that's that's 1.5 milliseconds right that doesn't sound right five no that's right if i if i make this if i make vertex processing go up by oh wait right no i divided by two i i forgot that this was per vertex pair let me start over so cal so okay so we have it's 16 extra cycles per vertex pair if you have 6 000 vertices that's 3 000 vertex pairs which is divided by 62 500 is 0.7 milliseconds so it'll be 0.7 milliseconds more on the rsp to process everything but if you save more than 0.7 milliseconds of render time for not drawing this stuff behind the yeah of course the scene then it is worth it right so how much do you save for an occluded vertex or triangle you don't draw the triangle to the rdp if it's but how many cycles is that it's saving rsp it's saving rdp cycles oh okay so it's gonna be strictly worse on the rsp well no but it saves rsp cycles also right because then if it's occluded it finds that out here instead of drawing it which is here so you save like 115 cycles yes okay triangle that's occluded on the rsp but then also on the rdp which is again normally this is the occlusion plane is a thing that you use when you're rdp bottlenecked yeah to pay some rsp time in order to save rdp time right but if you're always paying this and i'm rsp bottlenecked it's likely that it's not going to be bad on my end if yeah so so the occlusion plane is something that you want to use in a scene where overdraw is a problem for you if you also i can just opt to not pay those 16 cycles and just don't have the occlusion plane that's what you're doing right now with no yeah yeah but you're making it sound like it's on a scene by scene basis not on game by game if you swap between microcodes in the middle of your frame right right okay i gotcha i can just swap the microcode out on level load i can have a microcode per area this is gonna be crazy you can i mean you can have a micro you can have them swap microcodes on a frame by frame basis you don't want to swap microcode every frame because then you have to pay the cost of it but you can like while you're running around pay attention to the like rdp rsp metrics and if you start having like if you if you look at like the ratio between the rsp uh fifo being full counter and the rdp uh commands buffer being empty counter and all of a sudden the scene goes to a place where the commands buffer is never empty and the fifo is really empty then that means all of a sudden you're rdp bound you're gonna get hitches like that yeah i don't i don't want to do this outside of loading zones i'm pretty sure then well then in that case um what you want to do is use the occlusion plane in some scene that has like a large yeah exactly that's the plan and then yeah yeah that's loading in a different microcode is like one millisecond or so it was something like that when i profiled yeah i think you can here let me let me show it so that's not that much if i go to game and i go to a random place oh yeah i want a random place that has a uh less less varying timings okay so we're over here timings should be pretty constant because there's no skybox and everything yeah and then if i do oh i don't remember how to turn these on no i don't have that in this damn i don't have that in this version of hacker ot i was going to show the the bars let me let me see if i can sort it work anyway so this is like um 4.8 milliseconds total rsp time now i'm going to like mash the button to swap microcode versions um so i guess talking the microcode version is going to change the now you're not going to really be able to see this very easily but um because like they're all changing the amount of time the rsp takes so anyway i got it like i saw it at one point with other version of hacker ot where you have the the performance profiling bars and you can see there's like a one millisecond of time where it switches to one of the other threads yeah okay that's not too much or whatever it was something like that um anyway um but so anyway i want to get the occlusion plane version available for you so that if you use it and like some of your later stages then it can it can help you oh yeah i definitely will it sounds very useful all right so that's my that's my plans there will still be new versions but the um the uh z thing will have a minor change to the gbi it will take out the old um like z uh attribute offsets command because that's not really useful anymore once it just automatically fixes the um and then after that the gbi probably won't change and it'll just be like performance improvement on the with occlusion plane we'll find new performance ideas and we'll have to change the gbi i'm pretty confident maybe we'll see the way things have been going there's no way we don't all right well thanks for having me on the stream thank you for helping out you're welcome my pleasure all right uh we'll end the stream here then goodbye everyone
