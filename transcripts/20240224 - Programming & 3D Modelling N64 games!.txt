Alright, what will be our first mission here? Getting the live to show up on my end. Oh, it's not showing yet? Okay, it did just show up on my end. Hello, silly. Okay, do you typically wait for a few minutes for people to trickle in before we get into the meat and potatoes? No, I just start working and if people show up then they're there. So yeah, so this is like, first of all, thank you for having me on. It's an honor. I saw that you were featured on Gamers Nexus yesterday. So congratulations. Yeah, so with F3 to EX3, there were two goals. Increase features, like add new graphical features that were not before possible on N64 and reduce RDP time. And I think I was relatively successful at those two. And the cost is that our SP time goes up. And we can talk about exactly why I didn't see that being a problem for a couple of reasons. But it is what it is. And so I want to do a little bit of experimenting today to see if the problem is what I think it is, which is simply that all of the extra stuff and all the architectural changes I made to F3 to EX3 make the RSP go slower, which they do, but then because you've made the RDP go so much faster that now this is a bottleneck in your case. And if that's the case, then we can talk about what's next. I have some ideas about how to make a microcode that would suit your needs. And yeah, we can go there. So what do you think about that? That sounds very good. Hopefully. I mean, the RDP time was so much slower. And then we also have the higher vertex buffer, the comp plane. I expect anything between like 5% to 15% speed up from this, hopefully in the end. Yeah, that's what I'm hoping as well. Yeah, so let me, the first thing I think I would like to see, but this is your stream, so feel free to suggest something different is can you run your game with F3 to EX2 in the same spot that we've been experimenting with, except with the bug fixed so that it's doing 16 milliseconds as the RSP time instead of 8 milliseconds. Right, that is possible. Let me just undo F3DX. God, that's going to be annoying to do. But we can do that. Hopefully, you will only have to switch back and forth once today of going to EX2 and then going back to EX3. But this is the baseline. This is sort of one of the reasons. Yeah, I guess I'll sort of get into two of them right now. One is that, so like in OOT, if I pull up a scene that has 6600 vertices, it's going to be taking like 40 milliseconds on the RDP. And so you don't notice if it's taking 15 or 20 or 25 milliseconds on the RSP because it doesn't change the total time. And so I have done a tiny bit of like ABE testing, but mainly I was looking at like do RDP times go down, not do RSP times go up. And the other thing is that your profiling had previously said that you were only using 8 milliseconds of RSP time, so I was just totally not worried about it. But if it's actually 16, that's, and we're talking about like 22 milliseconds of RDP command, that's like pretty close. There's not a lot of headroom to make the RSP go slower and make the RDP go faster. So yeah, I want to start with the, just like make sure we're getting good numbers as our baseline before we change things. Yeah, that's very reasonable. Let me just figure out why it won't let me stash this. God damn it. So, yes, for the people in the chat who don't know who I am, my name is Soren. I am a person making F3DEX3 custom microcode for N64, which Kaza is trying to use in Return to Yoshi's Island. I also made, was the director of Triforce%, which was the Ocarina of Time arbitrary code execution thing that you may have seen at GDQ a year and a half ago. I do like N64 music arranging. I've been modding music into Ocarina of Time for like almost 10 years now, and I used to build synthesizers. I have some of them on my YouTube channel also. Yeah, and he also made the Sec64, the program we use for all that stuff. I forgot about that one, yeah. So, Sec64 is the N64 for the first party games, the music sequence format, and this is the program to import and export. Dude, what the hell? Okay, there we go, finally. Let me just make sure it boots up fine in Project64, and if it does, I'll put it on the N64 with all the fixed compilers and the fixed profilers. Do I see Project64 1.6 on your screen, Kaza? Yes, I'm still using it. It's just so convenient to use. Parallel still doesn't work for me. I just can't use it. Which flashcard are you using also? The Everdrive X5, I think. Oh, they tell me I need to turn you up. Is this better? Can you say something? Hi, everyone. I can adjust the audio levels in my end also, if you want. Yep, this one here, better, okay. So, are you aware of the Summer Card 64? I've heard of it. I think I tried to get one, but I couldn't. So, I have an extra one, if you want me to send that to you at some point. I don't think you need to. I'm fine with this one. I fucked something up, it didn't boot. Oh, it's the GBA. All right, I need to unstage this too and somehow just discard it. And hopefully now it works. This should just be the old F3D-EX3 that you sent me a long, long time ago. That's what we're going to compare to baseline. Oh, you're not interested in comparing to F3D-EX2, because that's what I'm sort of referencing. Well, I'm using the one that you made like a year ago or something. You remember that one? So that, I mean, I remember it. But like F3D-EX2, if some performance things are what I think they might be, then F3D-EX2 would be even faster. Oh, okay. I guess I can take a moment, whether this is a good time or some other time, and explain what the architecture changes were about how vertices are processed and lighting is done. Is this a good time for that? Sure, you are free to do that. Let me pull up a little whiteboard here. I didn't exactly think about how I'm going to do this. The job of the RSP when it is doing vertex loading is to take vertices in model space, compute lighting, and transform them into clip space. So you have a vertex. You need to somehow convert it to model space by multiplying by the M matrix. Sorry, you convert it to world space. What is that? I love the music, by the way. I might have to maximize you here so they can actually understand what you're talking about. But really quick introduction. I booted it up, look at the GFX time. 21.7. Okay, so that's good. So this is with old F3DX3? Yeah, old F3DX3. Okay. So I don't remember exactly what features I had in at that time, but if at that time I still would have had the overall change in the architecture. So going from 21.6 to 25... 27 even. I actually have 25.5. Yeah. 25.5 is like... That's a reasonable thing. Going from 8 or 16 to those is like what could possibly be going on. Yeah. Yeah, so good to know our baseline. Can you take a screenshot of this and save it somewhere as a reference? So we can go back to it later? Sure, sure, sure. Yeah, so while we're... Oh, yeah, yeah. Why don't you take the screenshot with all of them also? Because this is garbage data. Oh, oh, oh, I see. Okay. Yeah. Yeah, the vertex and... Okay, yeah. So in the microcode you have to somehow take your vertex datas which are in model space I should really just get text out here. Model space, right? So model space, you multiply by m matrix, you get vertices in world space, then you multiply by p matrix, you get vertices in camera space, then you multiply by p matrix, you get vertices in flip space, and also you need to do lighting. And along with the vertex position, there is a vertex normal, which is normal and that's in model space. And if we're doing just directional lighting, we will have light directions which are in world space. So the job of the microcode is to somehow figure all of these out and some relationships between them in order to be able to do the lighting and the transformations. So the way F3DEX3 does this is actually a more straightforward way than the way F3DEX2 does this. In... Well, first of all, so the v matrix and the p matrix are already pre-multiplied in the CPU code. In both of them. So there's never a separate v and p matrix, it's just one vp matrix. And this camera space is not actually a step. You just go... You know, you can talk about world space, you can talk about flip space, and you can go directly between them with multiplying by vp. So what F3DEX3 does is you start with model space vertices, it multiplies them by the m matrix and gets world space vertices in memory as it's processing the vertices. Then it also takes the model space normals here and multiplies them by either m or m inverse transpose. And I'm not going to go into a whole linear algebra lesson of why we need m inverse transpose for that. But you can sort of just say, well, for approximation, if the model matrix is just like a rotation and a uniform scale, then they're the same thing and you can just use m. So F3DEX3, at least in that case, doesn't have to worry about m inverse transpose. It takes the model space normals and multiplies them by m, and you get world space normals. I should go back to text here. World normals. Right? Then if you're doing lighting, it just does the dot product between the world space normals and the world space light directions, which is very cheap. And that tells you how much the lighting needs to affect that vertex. And then you multiply by the color or whatever and store that as the vertex color. And then also it will take the world space vertex position and multiply it by vp to get the clip space vertex position, which is what you need to draw it on the screen. And if we're doing point lighting, which part of F3DEX3 was changing this architecture so that it would make point lighting faster, specifically the performance penalty for each additional point light. Like if you had five point lights and then you moved up to six point lights, that extra time is lower in F3DEX3 than in the F3DEX2 implementation of point lighting. And the difference with point lights is that... Let's let me switch colors here to some other... Just so it's clear that I'm making a drawing here. So we have our 3D model here. You have a vertex on the model. You have a normal sticking up from it. And then you have a light source off somewhere. Right? What it's doing is it's making this vector from the vertex to the light source. And it's both measuring the length of this vector and making the light dimmer and dimmer as the light source gets farther and farther away. And also comparing this direction to the direction of the normal. And so this position here is the light position in world space. The light doesn't have a direction anymore. It's just the position. The direction comes from subtracting the light position from the vertex position. So for point lighting, then... If I go back to my text here. So we also have light positions. And world space. One second. Someone's asking if they're watching a tutorial. No, this is someone I'm live on the call with. He's explaining the new microcode he's made right now. We want to make sure this microcode actually works here and makes the game run faster. We're expecting this to be a huge improvement. Yeah. I'm not a video. Hi, everyone. Maybe I should have spent some time on overlays on my end to put my name and my, you know, whatever. Anyway, so you have light positions in world space. And in F3DEX3, because we've already transformed the vertex position from model space into world space, we can just directly compare the world space vertex position and the world space light position and get this vector. And then we have the world space normals. And so once you have this vector, you can just directly compare it. And so it's very straightforward. Except for this MIT business. But leaving that aside, it's very straightforward. The thing is that this is two matrix multiplies for each vertex. There's the transformation into world space and then the transformation into clip space. Or rather, multiplying by M and then multiplying by VP. And you have to transform the normal by M. You already have M in registers, so there's no extra load for matrix. But you still have to multiply the normals. So this is three matrix multiplies for each vertex. In the vertex processing. And once the normals are transformed, then they also have to be normalized. And this is because the M matrix could be any size in terms of any scale factor. And so if it just happens to be really small, then it'll make the normal really small. It'll make the lighting really dim. And we don't want that. Excuse me. So it has to be normalized after that. And this is also because in F3DX3, you have the option of having your normals encoded as act normals, which is this new type of, it's called octahedral encoding. And with those, the normal will come out of the algorithm with sort of an arbitrary length. It's not just always a constant length regardless of the direction. The length sort of changes as you change the direction. So there's three matrix multiplies and this normalization step. And then there's sort of a straightforward lighting calculation. If we now put this aside and talk about how F3DX2 does it, it's less understandable immediately. But it ends up being faster if all you're doing is just really basic directional lighting. So this side is the same. Let's see. What do we got on this side? I think that's a little overkill. I feel like the people here are not really there for the tech lesson as much as we just making this thing. OK. Well, I'll skip it to be a one minute thing then. In F3DX2, it pre-transforms the normals for the light directions by M transpose into model space. So it's basically transforming all of the lights back into the space of whatever bone you're on every time you switch bones. And then you don't have to transform the normal for each vertex. Oh. And it only transforms directly from model space to clip space. So it's one matrix multiply and no normalizations in the RSP for each vertex if you're not doing point lights. If you're doing point lights, then you add one more extra matrix multiply compared to F3DX3 and there's extra stuff. But if you're not using point lights, and that was one question I was going to ask is are you ever planning to use point lights in. Rty. No, absolutely not because I want to make sure and runs fine on emulators. So I stick to just my f3dx to F3dx, right? We have quite nice to X Majora's Mask has point lights, right? But everything here is vertex colored So it wouldn't really fit Like it would so are you not using lighting? I use world lighting But it's only for moving actors and my entire world is vertex color I have a few places where I use point lights, but I just fake them via vertex colors. So I just run them on a CPU. Oh Okay, so you're using one light source for actors and then all of your scenes are vertex colored and The one is the one light source is just always at a constant angle or is it like based on the Sun? Yeah, so right here if you see this level I have my Sun position. I'm there So that's where my light source is but some levels have up to like Seven light sources active at the same time because there's like stuff in the environment and I make it a directional light that I compute at runtime Okay, so it is so you're using up to seven directional lights And then your levels are not using lighting at all exactly okay, so Yeah, good to know so Yeah, so basically The old with the old f3d x3 version that you're using that you're using is the baseline already has this system, but it doesn't have some things like the occlusion plane Which it's doing the computation for the occlusion plane for every vertex, even though you're not using the occlusion plane So if it has the new system, I just compared it to f3d x2. It was 200 microseconds faster than f3d x2 On the GFX, are you talking about RDP? No, did the GFX task was 200 Microseconds faster on f3d x3 the very old one Then f3d x2. Yeah, I thought okay. You were just saying a minute ago that you Couldn't check f3d x2. No, I just did I managed to do it. Oh, you just did. Yeah. Okay Can I see the timing for that? Sure, I had it on screen for like a few minutes just now you can put it back on. Sorry. No, it's all good So right here this is I've heard over 200 frames so it's gonna take a bit to build up wait Something's wrong with the camera I Think something's in the camera and let me just zoom it out again. I Don't know why the camera is so zoomed in this is weird. There must be some kind of bug. Let me just restart the game That Way go Do you see it? Okay. Yes, I see it now. Yeah, it's a new to Yeah, this is ex2. Yes, I Don't know I don't have any idea how F3d x3 from like a couple a year ago is faster than x2 in RSP time because It should be slower. It is very weird, but Okay, then that just means we have more Performance investigate. Oh, well, but okay, so some of one one sort of Nice thing but also an issue here is that like if I add a ton of extra performance counters to ex3 You get those performance measurements in ax3, but you don't get the same performance measurements to in order to compare Example this might be Waiting for the RDP a whole lot and that's why the time is is high So like you may remember in my video about the performance I had times where like the RDP was 45 milliseconds and the RSP was 42 milliseconds. Yeah Yeah, it's like 40 seconds because it was waiting for 15 milliseconds for the RDP But you can't measure that other than with f3d x3 So we can't really compare that in in the old version, but there's still a couple of experiments that I think we can do If we go back to the modern f3d x3, but before we do that, can you take the screenshot of this as well? Sure So I'm guessing that this is kind of a Similar time on in terms of actual RSP work But just happens to be that, you know Ex3 is doing or the old the x3 is doing a little bit more Work and it's so it just sort of shuffles around the distribution of when it's waiting for the RDP and when it's not and then It ends up finishing a little bit faster. Yeah, because it was like waiting for less time That's my guess and then with the newer x3 Just because like it has actually gotten to be more work then it's finally caught up and is finally slower But we'll we'll see It is a 20% higher time. So that's a little crazy Right. It has to be like a really really big thing somewhere well, but so this is the thing is that the I just went through all of this this discussion of like what What takes time on In the in the vertex processing the vertex processing takes like way longer in Ex2 in RSP time not memory traffic. It's like the same amount of memory traffic and everything, but it's taking way longer. So Having some large extra time is not by itself Like a surprise But having the extra time show up in the just going from old ex3 to new X Yeah, exactly is a surprise So I must I am imagining that what it must be is like actually ex2 is taking you know 12 milliseconds and all the x3 is taking like 18 milliseconds Yeah, both of them are waiting for the RDP and so it looks like they're both 21 and the new ex3 is slightly above that And then it actually like pushes everything. Yeah, I think you're definitely right. It's probably all like the fee for waiting thing here Yeah, so Let's can you switch back to the new ex3 and I will give you some At first it'll be just like a simple. Oh, can you comment out this line in the microcode and rebuild it? But eventually it may become a larger thing and i'll have to like make changes and then send you the file Does that does that work for you? Yes. Yes. Let me just I I don't work with this a lot. I just need to figure out how to just get it back right now Can I just while we're doing that? Let me put my um name in a In my overlay here so that people know who I am I have a I Am not a streamer someone asked do I stream? No, I don't um, this is sort of my second time on a stream ever so, um Yeah so that's why i'm a little behind on the um Being prepared to be a streamer business So Dude how is it not letting me stage just i'm just gonna use github desktop. Fuck this Do Do Do Do you know how to just remove this It just won't let me The the stash here not the stash the half applied thing It's not letting me apply for the x again I use git at work all the time and I have to admit that when it gets More complicated than like the normal Regular stuff I end up googling a lot. I see fair Git merge abort maybe The language server crashed restarting beautiful So Oh, there we go Do you They look like the same thing All right, I think f3dx3 is good to go again Okay So Guys I just used project 64 1.6 You shouldn't use it if you're gonna play someone else's aromic because they can just put malware in there, but i'm I have no reason to get it's parallel because i'm not gonna play any one sec That's a little bit much there Oh, what are you testing? Oh your name? Is It's probably fine and then I do There we go. That's on top Yeah, that's good Right I'll improve this later, but hopefully that'll help Hello first day delay run Oh Yeah, we're back to x3, okay, so this is 27 How how does this happen it's it's it's one and a half milliseconds worse with no Changes to the microcode or the game Yeah, I don't know Okay, well, uh, let's play with the microcode and see what happens so Um, can you open the microcode? source f3dx3.s in your text editor vs code or whatever sure I did set up compiling this before so this should be pretty doable There we go Yes, I trust the author first i'm opening this There we go, i'm all ready, okay. Um, and so yeah open up the source file the dot s file And Can you go to line 13 34 not quite 13 37 1 1 3 1 Uh, 1 1 3 4 1 1 3 4 Uh, that is not the same as what it looks like on my end, can you do a Gotcha Already up to date prize is there you are pretty out of date um on that Could that be the reason? Do I have the wrong repo or something? Uh, what is 64 slash f3dx3 you do, uh, yeah, that's the right thing. Why am I out of date? Uh Well, I mean that's not what it looks like on my end Uh screen share with webcam line 13 34 on my end is Yeah, you're and you're on the main branch, right yeah, I mean it says right this Don't expect the main branch to me, uh, well, it doesn't actually say what branch you're on. Can you do get status? Uh Okay I'm on And can you do get remote dash? Make sure orange dash what? dash v For verbose, yeah, that's the right thing. Um Well What the hell I don't know why it's not the same thing. Um I am on i'm on there and it's uh Is it maybe just the way my text editor displays it I said maybe like a unnecessary line somewhere Does it say like the line number of a file should be Yeah Pretty important. Okay. Okay. Can you go down to the end of the file? How many lines are in the file on your end? and 2719 No, me too. Okay, that's good But then go back to 1 3 3 4 Oh 1 3 3 4 I had 1 1 3 4 Oh, okay that explains. Um, yes 1 3 3 4 almost 1 3 3 7 Um, can you comment out the branch if not equal to 0 lighting entry point? Just line 1 line 1 3 3 4 just comment it out And and rebuild and put that in the game so this this is going to cut The entire lighting computation um For anything that's vertex colored you will get your vertex colored and for anything that is supposed to have lighting you will get um The vertex the normals will become the vertex colors All right. Oh shit. Why was this again? Wasn't it? Lip pr. Here we go. What do you code? I Wish I had a better way. There's a setup so that when I build it it like goes in right away That would be very nice. So I just have a script on my end I mean i'm in linux, but I have a script which runs the make file copies the microcode binaries over uh touches the right thing in the like make system for the Hacker oot project so that it will rebuild that file and then uploads it over usb to the summer cart 64 and then I just have to reset the console and Yeah, yeah, that sounds a lot more than what i'm doing All right, so i'm also changing this all the time and hopefully you won't be So I'm just gonna keep the folders open so we don't have to go through that again Uploading So this is just taking out point lights right now This is taking out all of lighting. Okay. Okay. I see I see how it is if the if the theory is that the like the just the vertex processing is just too slow Then this will make the vertex processing go substantially faster Yep, that checks out Yeah, that definitely looks like we have no lighting yep Oh, that's substantially higher I already saved two milliseconds Okay Okay, then that doesn't explain it because This was this should have taken out while I can compute. Hold on. I have I wrote some numbers out here All right, so if we get rid of that that should take out My calculator here 54 Right shadow why it is still four frames short, but what you have to look at is first of all tech m and comment here The the tech m is 1.2 milliseconds less and the comment is one millisecond less So those are going to be the real big players Plus we get occlusion planes. So that's going to be even more Like imagine an occlusion plane right here that hides all the floor down here and doesn't even consider the triangles So that would be huge That should have saved 3.8 milliseconds Oh getting rid of the lighting and it actually saved two Ish but the the baseline the 27 was worse than it was a couple of days ago. Yeah, so um Yeah, uh something's something's up I see that the fifo number is also going a little bit um bonkers um There's it's it's up to two. Sometimes it's up to one I guess 1.5 sometimes I guess that's not A huge portion of it. How did you compute the 3.8? Which values did you use for that computation? Yeah, so a good question. So what I did is, with the RSP assembly, you can sort of first approximate it that it will issue a scalar and vector instruction in every cycle. That's not completely true because when instructions have dependencies, it will stall for those. So this isn't like a completely foolproof method. But basically, I counted the instructions for different sections of the code and then I'm multiplying by your 6,600 vertices and just saying, okay, well, it took this many instructions. Most of these never even use sliding. Well, oh. Yeah. Well, that explains it. Yeah, that's what I thought. Okay, well. So the amount of vertices that don't use sliding, we can approach it by looking like this and subtracting Mario's vertices. Actually, so 4,300 of them probably do not use sliding and it's likely even more than that. So maybe 2,300 of them use sliding, actually. Okay, but then that also means that the penalty from going from EX2 to EX3 for all of the non-lighting vertices should never have been that high to start with.  Okay, well, so what I can do now is, this'll be easier for me to do on my end and just send you the file, but I can cut out the vertex processing for the occlusion plane and see how much extra, because that's for all vertices, and see how much extra time that that gets us. Okay. I'm not super hopeful and I have lots of more ideas, but that will help because sliding is not the primary thing here in any case. Yeah, so let me put on my screen share again here and I'm gonna try to do some, hopefully correct coding and we will find out. So, all right. So vertex store, the end of this is the occlusion, the end of the occlusion plane stuff. So this is all, this can all go. We need a J-R-R-A at the end here. Perfect. Vertex clip, I need to store these. I don't need these. I don't need these. This vertex clip can go here. This is a comparison for, this is A of that, C,  skip fog, this is occlusion plane, this is occlusion plane. Move that up here. Clamp C to zero, clamp fog to zero. Let's see. This can go. So like the occlusion plane isn't that much extra time simply because it's like interleaved with all the other parts of the vertex processing. So like there's a lot of things that there are dependencies and so you can add an extra instruction in between and it doesn't actually take any more cycles but I'm just gonna try it anyway just to see if this will help. Okay, so this is V26, right? V26, this one. Okay. Well, say for extra reason, we have a different result. What we believe right now is that in my game, the memory transfer speed is just optimized so much already that the RDP is less of a bottleneck and that's why it's more evident in like other people's text than in mine and that's why it's worse here. Well, yeah, but now the results are just looking like there's something like just weird happening because it went from 25.5 to 27 with supposedly no changes to anything and then when we get rid of lighting, it only went down a little bit and there's just a lot that's like, this isn't making sense as coming from where it was before. Actually, I think this is gonna be, because I didn't look at this in advance of like exactly how little, like if I pull out all the instructions for the occlusion plane, it's actually just gonna like, it's gonna take a bunch of time for me to do it now. Well, maybe in like another 10 minutes or something but then you'll only save like a handful of cycles because, well, okay, I guess I'm already halfway through. Let me, let's see, we have occlusion results here. That was, that's that, this is V26. There, that's there. What the hell did I do with this? This in here, right. Okay. That, this is for, hello, that is Saran, he is the developer of F3DX3, which is a new microcode that hopefully increases performance and it brings cool stuff like cell shading and ambient occlusion and more stuff. So we are right now figuring out why F3DX3 on my game only doesn't seem to increase performance. And that's why we're looking at assembly because the assembly is the corny world. Microcode is written in assembly. And then we do, we have a, screen, I did another one, oh no, I didn't.  Right, this is what I was looking for. Yes, Saran also made Sec64, which we still use a lot. I generally pronounce it as Seek64 because the way you're pronouncing it sounds like something else. Seek, I see, because of sequence, yes, that makes sense. Don't want to get a Twitch community guidelines strike. Dude, I'm risking a guidelines strike every time I'm talking about fog in my levels. Yes, he also made the Breath of the Wild Ocarina of Time text demo. That's probably it, let me see if this actually works on my end just to, before I waste your time with sending it to you. All right. All right. It'd be very sad if it was the clipping plane though, but I feel like that wouldn't even really make sense. Well, but that shouldn't be the, like this is, we're talking about like another 20, maybe, no, not even that, like 15, because it's for vertex pairs. So it's like an extra like 20 or 30 instructions. What happened here? Something broke. Something broke. One second. I think I got something. This is video input. There we go. Just have to run a little command line to get my camera working again. Let's see what I, whatever. No, I think I broke vertex processing. Shit. Yeah, this is what happens when you try to just load something on stream, make something new on stream without a, yeah. It's a, welcome to Ocarina of Time. All right, let me, let me try again. The performance looks pretty good though. Well, the performance is not drawing the right triangles. Yes, I know. That doesn't mean anything. Hmm. Let me try again. This and back here. And then. All right. That's. Let's try again. Hopefully not mess it up this time. We are here. Okay. Do a little, a little bit more incremental here. This is. Oh, I think. That may have been right. And I just forgot to change for it to, let's see. No, that shouldn't have been setting. I actually don't remember. All right, let me try again. And if it breaks again, I think I may know what I did wrong. Sounds good.  16. This. This. This.  Here. And then. This. This.   Yes, tea time. I got the right coin area and done our stream. I can shut up real quick. I'm sorry I'm just busy. Sure. Oh, well, we're gonna have a little bit of a lighting issue. You guys are just gonna have to live with that. It's every game that I'm just fixing broken code air somewhere like this. Depends on how difficult what you're doing is. So this is the right coin area I did off stream. Unfortunately, you do not see it with the lighting. Otherwise you would see the environment being lit up around the fire here, which would look very nice. The fire looks very nice as it is though. Oh yeah, I like it a lot. Uses a sheer matrix. On the fire? Yeah. Such a seal visual, but it looks good. Oh yeah, yeah, yeah. It was very convincing from like far away. It just looked perfect.  Oh, that was a bug. Is there a light in the fire? Yes, there is. Yeah, the vertex colors are baked into level, but there's also a real directional light coming from the fire when you're near it. It's a donation. Thank you for the donation, one of ShyGuy. I am going to skip CrazyBus. It's not CrazyBus. It's not CrazyBus.     Hope you've been well. Also from Remix, thanks for being cool. Thank you for the donation. Sorry, I mistook you for the CrazyBus guy. That was not you. Can you send turkey style fuck so the player can't see the entire scene? I could add fuck to this, but I don't know if that would look better. Maybe, maybe some dark fuck, but that kind of ruins the lighting effects, you know? All right, so I think the problem is just that I'm reading everything as, or a lot of it as being occluded. Like I changed computing occlusion in plane, but I didn't change the part where it draws triangles and it checks. Yeah, here it is. No, no, not that one. It's, where is it? Clip occluded. Here we are. This is nine.  Hopefully that does it. Dark fuck at the bottom only. Well, there's fuck here, kind of. It's just a fade out. You can't just really scale fuck with a value like that. It's just not supported. The fuck is either applied to like the whole triangle or not at all. Is Boshi in the game already? That's a great question. Cause we absolutely planning to put the Boshi here. You're going to have a gunshot on. Ah, dang. Sorry. Still broken. I guess I shouldn't try to do that much of a change on stream without any testing. So let me try something else. So this is a different thought I had about a way to debug this. So under the assumption that the problem here is that EX3 is just like so ridiculously much slower at vertex processing. We can change the performance counters because the way the performance counters work is there's like reorganize the microcode. So there's, I'm not using all of the registers. And so I just have like extra regular registers, scalar registers lying around that I can put whatever I want in them and just leave it in during the entire processing. And so that would include like the vertex counts and the triangle counts and stuff. So I can like remove those and instead use those vertices, use those registers for counting other things. And so I can count, this wouldn't be like at the same time as the other performance counters would replace them, but I can count the actual amount of time it takes on the RSP to do vertex processing. And I can count the actual amount of time it takes to do triangle processing. And then we can see what like percentage of the total is those. And that hopefully will give us some info. So let me try that instead. This is hopefully less chance of screwing up, but we'll- Oh, it said easy. I thought that was gonna take a long time. Well, we'll find out. Sounds good though. Okay. I could use more practice at live coding. So, okay. What I'm gonna do is I have a little bit, let's see, end variable DMEM here. So I have, it looks like in this version, I don't know how recent this is, but it looks like I have eight bytes of extra DMEM that I can use. So I can make a DMEM variable to hold the initial state of one of these counters. And then I can use the registers to hold the sort of accumulation of them over some time. So that's what I will do. So this is a clip, well, I can actually put it anywhere. So let's make, let's go here. So this will be, vert, vert time, zero. And then I'm gonna do perf counter one. That. That. That. Copying back is good. That's changed the documentation. That's fine, that's fine. All right, perf counter two. And the reason Mario has no colors right now is that we changed the GBI in FBDX3. So I need to update the way I do lighting before they will work. And let's turn on 64, of course, then the lighting just works. And yeah, this will be the retro pipe for this level here. This is course 12 out of 15, but I might still move it to slot 13 or 11. I'm not sure. We have Mario Kart 64 in Mario 64. Yeah, yeah, this is, I have like a retro pipe on every level. That's like referencing a retro game that came out before the N64 life cycle ended. And this one, it shows Mario Kart. Okay, that's pretty cool. Cause it's like Mario Kart had Mario 64 in it. Yeah, exactly, exactly. It's kind of the idea. I'm also gonna add the train here. Nice. Are you gonna have it smack Mario and launch him a large distance? That would be funny. The trains actually do that in the overworld. So yeah, I actually think I will do something like that. All right, so for vertex, this is pretty straightforward cause I just have to start here and the end, this is J-R-R-A and I have it so that R-A is run next deal command. So I need to comment some out some code too. Let's do. Yeah, Holly, that is the idea. Make file, I am on. No, I'm not. This is on. Yeah. Okay, so I got that already. Then I'm gonna comment out this cause I'm not using that. Let me just make sure that this works. I was gonna do some 3D modeling while I wait for you. That makes sense. Entertain the people a little bit.  Still works. Ah, that looks good. So I gotta change these counters. So next handler. No, we're not fixing the lighting. We're trying to improve the performance right now. The lighting should be trivial to fix. Or at least other people have fixed the lighting before. So it's not gonna be too difficult. And there is a Mario Kart retro pipe, but definitely not Diddy Kong Racing. That's not even a Mario game. A few more retro pipes are planned. I forgot what they are though, but they're good ones. I'm just gonna have to trust me. No, I'm not adding a drivable kart. We want the fun to be for Mario's movement and not just random things like that. It kind of feels like, oh, you like Mario 64. Well, fuck you. Here's Mario Kart. I don't want that. Hi, Casey, why is your keyboard louder than your voice? It is what it is, man. You better enjoy the ASMR. It might be my keyboard also. No, it's definitely mine. I can't hear yours. So there is a finish line or there are going to be star bits. It will be a race to the finish type thing. I'm thinking you have 40 seconds of time to do this or maybe 45. Yes. Yes, that is the retro pipe. Arthur had the funny idea of making Mario 64 retro pipe and I'm kind of down for it. Just going to put in Bob on Battlefield and make it drop the frame rate. So it's like this is your retro experience. Yeah, you know you're having a good day when you got to start going through the assembler source code. I don't know. There's a bunch of there's registers that the RSP can access from the RDP and like start and end of the command buffer and stuff like that. And one of them is the clock counter. And these aren't in a header. They're like defined in the assembler as like predefined register names. And I didn't I don't know what the name for that is because I haven't used that from the RSP yet. So I have to go through the compilers or the RMIPS source code to find this. But that should be pretty easy. OK, I say it should be pretty easy and then I immediately fail.  I guess it works for me. And as long as I don't play anyone else's romeg, I can't get tagged. If you use Project 64, I might hack you. If there's too much in your bank account, you should just be scared. Yeah, I'm just going to hack myself on accidental Project 64. So next we got to add the start line here. To this level. See, I actually had the idea to just put a crypto miner and all the idle cycles I got on my CPU because it's like 75% idle. Now I have actually a reason to.  Oh, interesting, there is a calamari that doesn't even have these as like a going down thing. If you want to make a good port of this in the Mario 64 soundtrack, that'd be very cool. I definitely will need that. Oh, I'm glad you're enjoying it. Finally, in Peach's Asphyxiation, did you like it, at least? Do I use the vanilla sound font? I use huge parts of the vanilla soundfont. And if there's something in the vanilla soundfont you want to use for the calamari desert song, then we can definitely use that. Yes, the Bowser magician is still going to be a thing, I just haven't done it yet because I still need all the animations. Someone offered to do the animations in 2021 and they kept saying I'll do it, I'll do it, I'll do it and then they didn't do it. And that's why you don't do call-ups. I think this looks good for a starting line. You didn't give it a 10 because you're saving the 10 for RTYI? Damn. But it sounds like you liked it. But are you going to go back to every other hack you played and be like, yeah, actually, I have to normalize my ratings and just put them down to points? No. Isn't the case, Logic, that you're never allowed to read anything at 10 because nothing can be perfect? No, I think you should rate it on a normal distribution. So you should give almost every hack a rating between 4 and 6. Actually, 5.5 is the medium then, so between 5 and 6. I think this is all we need for the starting line. The hell? Do we also use this for the finish line? We do. So when I say anything is 6, they think it's a 5 because they're too kind to rate it. True. True. Whatever you say, dude. Yeah. And what's with the Boshi? There's going to be a Boshi that you have a shootout with. You know, that's like a whole cowboy level. So you will be doing cowboy shenanigans with the Boshi. Don't even know why you're on 7, is that there's so much shitty things you can do. True, but if you do that, then you lose voting power. Because if 7 is your average and you vote something at 10, you're just moving it 3 points above the average, right? And someone who actually votes around 5 can move it 5 points above. Yeah, it's an experience. Very understandable if you hate it. It is not a good experience. True.  As Mario has a future color, it's a bug with the GBI right now that I need to fix. It's because we're in the process of switching to a new microcode and it changes a few of the comments we need to use. But first we need to figure out why the microcode does not perform better on my end. And then we can make the final switch. Okay. Oh, and then render distance hurts. That's also way too big. Does it remind me to just get inaccurate with FDX somehow rather than problems being actually shittier? No. I think we're just going to take the strain and attach like three wagons on here and then have it go in circles forever and forever. The question is, okay, the thing is, this is going to be like a 40 second race or 45 second race. And there's a shortcut you can take through the tunnel right now, which I think is kind of cool. But it's also the platform here is not that exciting, but it's really cool that you go through the tunnel. Do we make the train come out of the tunnel this way maybe to prevent that or to have people wait at least like a second? So it's like a hidden shortcut because you actually have to wait a second to go there or do you have to go after the train? Ah, shit. Maybe I should have compiled F3DX with O2. Surely that would have made a difference. Thank you for the great recommendations. The train has that 64 on the front of it. I feel like you could change that to something else. Oh, yeah. Yeah, I can kind of see the vision. Maybe your own logo. But it kind of has to have the same color, maroon, desert, white, right? Because it's the retro stage. If it's different, it's going to be kind of eh. Does RTYI have an antagonist who would have a logo or something like that? The antagonist is just Bowser who has a logo. Well, yeah, I guess we got to leave it then. Can the train move? Of course, of course. We got counters? Yes, the display of them is broken, but I can fix that on my N64 side. The counter that was previously vertices and one of the tricounters is now amount of time for vertex processing and the other counter is now amount of time for triangle processing. That was fast. Let me fix it on my end. Well, it's not completely done yet. Let me fix it on my end and make sure that I am not sending you garbage. Yeah, I'll add smoke coming out of the train door. That is a must-have. Particles are super cheap in this game because they're all just batch-rendered. Can you improve my FPS? Unfortunately, the human eye can only achieve 24 frames per second. That's an unchanging fact. You're stuck with that. I think you've read up my brain. Anytime I play anything now, I make places, jokes and talk in German accents about how I improve the FPS. What the fuck? Is that a real thing you do? That's fucked up. I think they're probably trolling. I can kind of see the place in this talk though. I can see how people would latch onto that and really like to use that as a metric in the games they play. Shit, Arthur found out my trick. If we can only see in 24 FPS, that's how does 30 and 60 look different? Placebo. I have a question for you. I would like to make a fangame with the vibrant 796 game like Mario 64. Do you have any tips for me, hopefully? I guess try to recreate the texture filtering, the blurry stuff. I feel like that's what people most remember about N64 and the low resolution. Is there usually a big Mario Kart logo above it? Yeah, there is. Wait, that's not there in the first lap. I never noticed that. Look, it's there now. I'm blind. Nevermind. I suspect that's an actor. No, the camera just zoomed in. Oh, okay. That would make sense as an actor though.  Uh, well, I, that doesn't look right. Something doesn't look right here. Oh no. Let's see what happens when I get in game. Well, wonderful. Uh, what can I do here? Let's just do this. I think I'm putting some garbage in there. Nintendo lo-fi music. I can do that. I can put some lo-fi music on. Now the stream is a little less awkward. It's actually 4D. All right. Okay, chat. The thing is, okay, 1D is just a point, right? It's just a line. 2D is like a line in height. 3D is like when you play a video game and it's depth. But 4D, it's not smell. It's when the chair moves as well. 5D is when they squirt you with water also. Yeah, you get it. Yeah, that's right. What is going on? That should be fine. I am trying to figure out what this text is. What are you doing with the market level? It's a retro stage in this game. Look at this. It's just a plane. That's what I need. Oh, that's what I need. Wait, what did I? Oh. Idiot. That's what I did. Coding too fast. Shit, where is this video? I need the Mario Kart video back. There we go. So, okay, I see what this is. I think I have to make a new material here. This text is not working for me. Okay, that is what I was hoping to see. I think this is probably right. Very nice. What's the condo now? Yeah, I see it. Okay, so what this means is that, like, right now, the, I have an arrow here, don't I? Somewhere here. Arrow. Right? Okay, here's an arrow. Why is it not letting me select it? All right, so this is the RSP task time just from start to end without subtracting things. This is the RSP task with only the times that the microcode is actually running on the RSP. This is the amount of time it was waiting for the FIFO. So this is the amount of useful work the microcode is doing. I see. This is the amount of time the microcode was processing vertex commands. This is the amount of time it was pressing triangle. Okay, so these are like five to six each, which makes like 12. And then we have 15 or 16 is the total. So the other four milliseconds were either just processing tiny commands, which are just shuttling them over to the RDP, or matrix loads, or just anything else other than vertices or triangles. That seems pretty reasonable to me. This will, these will count. This is just like from starting the vertex time to finish, starting the vertex whole process to finishing it. And that includes the like waiting for the vertices to be loaded. And the triangles time also includes waiting for flushing those triangle commands out to the RDP. Because that's within, like this is just like just it stops timing just before it runs the next instruction. So this actually includes some of this time. Okay. Which is the waiting for buffer. So I'm gonna send you this source, and you build it, and then we will see whether the vertex time is ridiculous, and whether this is like, if you add them up, it is way less than the total that you're seeing. That make sense? Yep, that sounds good. Okay, and we go back here. And camera, and then I will send you the f3d-ex3.s. And you can just overwrite yours. Oh, I have to pop up in the chat here. Okay. All right. Let's test this new microcode. I can't just make everything bigger. The problem is, if I touch my OBS, it might crash. My OBS is extremely unstable. So if I touch that right now, the stream might just go offline. We're both evil. Damn. Please reset your damn computer. It's so cursed. I don't want to lose everything. No, I do not want to make my own emulator. I just want to make my N64 game. Ideally, I wouldn't have to deal with emulators at all. Is case implement f3d-ex3? I already have f3d-ex3 on. That's why when I'm in-game, you see that Mario has no colors right now. It's because of the new GBI. The problem is, f3d-ex3 on my game runs significantly slower. So we need to fix that. Case, when are you solving world hunger and curing cancer?  Case, why didn't you do it already? That's fucked up, don't you think? I should not have walked forward. I am back. So I forgot to show you how to do it.      I forgot to give you something. You also need the new yield data footer. I just sent you on Discord. I replaced what was previously those four counters of vertices, triangles in, triangles out, and rectangles. It's now two U32s, which is the number of cycles for processing. So I've got to update the counters as well? Yes. And those are RCP cycles. So whatever you're using to do, like, divided by, I guess it would be 62 or 63 or whatever. And then when you have your volatile U16, the lines like 242 to 248 or whatever, like 243 to 250 on your screen. Those need to change to two U32s. Delete all of those and make it two different U32s instead. And that would be like the vertex processing time and triangle processing time. Right, so these are all dead. Yeah, well, two of them are now dead. Okay. And then you need to draw two of them. Which ones are still valid? This one here and this one? Well, so none of them are valid anymore, but now there are two U32s that are number of cycles for processing. Right, right, right. But I'm just going to reuse the variable name because CBA. Well, you can do that. Yeah, so these two are still the good ones. Nope, that was not it. Try no count vertex count. Okay, I see. And these aren't counts anymore, they're number of cycles. Yeah, I know. Try proc cycles. Am I even using... Am I dividing by the wrong number? Did I divide by the wrong number before maybe? Because I used 46. It's cycles per CPU. It's cycles per RDP or RCP is what you want. So the numbers might have been higher than they really should be. Well, so like graphics task... No, but this is the first time I'm giving you an F3DEX3 performance counter that is a... Well, no. The number of... Okay, wait a minute. So graph or whatever is just a CPU timer. So that's just cycles per CPU, right? Oh, okay, never mind. All fine. In EX3, the only timer that was actually cycled before was the one for how long it was waiting for the RSP buffer. So that's the RDP wait cycles. Right, so that one... That's this one here, which is by 46.875. But it is CPU, right? So it should be fine. So the CPU timers are fine. For the new ones, you need to divide by 62. Yeah, that's what I'm doing here. And then the only other one that you need to check is the one for RDP wait cycles for the buffer being full. How were you drawing that before? Wait one second. Let me just fix this real quick. Still drawing this somewhere. Don't need that anymore. Okay, now it compiles. What were you saying I should also change? What was called RDP wait cycles. That's another counter from the microcode, which is in RDP cycles, not CPU cycles. But how long the microcode is stalled waiting for... Oh, so this one here. Uh yes gotcha yeah that's right that's right yeah though it means if you're dividing by 40 instead of by 60 it's even less than it was yeah well we already identified a decimal issue beforehand so it shouldn't really matter uh the right after market sense check about it should be ah i see okay josh i can look into that came back after an hour and they still haven't fixed the volume differences maybe you need to turn yourself up a little bit someone complained about the volume a little bit again where are you physically in front of my computer oh uh nova scotia okay that explains it because that's the only place that's i'm on the west coast like near san francisco and it's the only place that's behind yeah i'm all the way at the east of north america oh what the hell this does not look right that does not look right to me uh well i think it's working on my end why don't you print out why don't you print them out just as integers like don't do any conversion just print out the integer value of each one because then you can just do the math later like so that's what you're thinking well my thing only supports without even the f32 just just do it without the f32 just look at it directly so it sounds like something else is going on did you write to them you copied the the right things to them i think so those two let's just look at that again uh yeah i think so and you like rebuilt everything that depends on that header hopefully yeah it rebuilds everything automatically when i just hit make okay uh yeah well it looked reasonable on my end is that um just to confirm you put in the new microcode correctly and like updated everything on that end uh yeah i think so let me just try that again maybe i missed this up so holly in the chat says soren have you ever considered making f3d ex4 i think increasing the number by one might fix this performance issue so it's funny you mentioned that um now i'm not convinced that the performance issue is what i thought it was but as of like last night when i thought oh it's just i've made the vertex processing way too slow i need to make f3d ex 2.5 for kaza which is uh the f3d x3 but with the like lighting and vertex processing backported from f3d x2 so it's like a mishmash of that um so yeah we'll see all right now i have definitely just now updated these two so you should consider the summer cart 64 no more moving SD cards and waiting for the coffee it's like three seconds that would be very nice that would save me so much time I wish the FI drive actually just worked but it just doesn't on my end it's us it has USB upload but it's super slow it's slower than actually copying to the SD card oh well the USB upload doesn't work for me it works once per time I boot my PC sounds extra stupid this looks like the numbers are at least consistent it's just not printing the right thing because yeah my my counter doesn't work like that okay yeah L and B hmm okay why don't you I think maybe it was right before and it was just the microcode wasn't updated so why don't you switch back the yeah your code changes that sounds like a good idea surely not converting to an F32 before and it's not gonna work yeah I mean probably will promote it because C does yes it does I was trying the game running it entirely without doubles and there is some random double promotions all around that just crashes that you know the single precision float not only are you planning to like actually try to solve that or is it not worth it I'm trying to solve that adventure at some point because it's only extra CPU time it's not extra memory traffic so it shouldn't affect situation well some functions become smaller because you have more registers available to you so oh yeah right I guess no but it's that they still only use the even register no no they you see uneven still really yeah you you've managed to fix that in the compiler I don't know it just works I do have a custom build of GCC so maybe that's why what the hell it looked fine in the overworld but then as soon as I switch levels it doesn't anymore okay so this is I think I might know what's going on this these counters are now yeah cuz it now it's fine again right right now it says it's taking 1.2 milliseconds for vertex processing 1.4 milliseconds for triangle processing but the graphics test is only taking 1.5 milliseconds total it's 4.5 oh sorry sorry I read graphics that yeah okay okay then that's fine so these are using the RDP clock sorry there are RDP clock counter so it's just like pulling in the clock counter at the beginning of vertex processing storing it to DMEM pulling in the clock counter at the end of processing subtracting them and then incrementing our amount of vertex time right so if you reset the clock counter in the middle while it's processing this is gonna go to hell so what have I tried to make the thread timing a little more consistent by limiting the FPS huh okay that's better okay that is what I wanted to see you have 10 milliseconds for vertices 8 milliseconds for triangles and 27 milliseconds well the ratio of the numbers is around the same as what you agreed of time yeah so this this should be you know 9.8 milliseconds plus 8.2 milliseconds is like 18.1 milliseconds right plus yeah a couple of milliseconds for other other commands or whatever but it's actually like another 9 milliseconds yeah something something's up so it's not just that the vertex process I mean the vertex processing is slower but like that's not all that's happening here something else is taking a ton of time you're not doing something degenerate like writing like a some sort of like prim color at between every triangle or something no no no no let's see so oh yeah yeah so so two more things so FIFO counter looks broken currently but can you build this with your when you have your make file oh and by the way I should let you know I got to leave in a few minutes but yeah I mean we can we can do this some other time but yeah this is this is very good info because that that mysterious now extra what is this extra like eight or nine milliseconds yeah 90 that would just like solve all of your problems right because like look at that look at that command time 21 milliseconds that's it that's the actual time the RDP is so the RSP should be around the same number and it's at 27 yeah yeah so I will think about this over the next week but one thing while we're still here for a few minutes so let's try to unbreak the FIFO counter but then also can you open up your make file for f3d x3 sure I didn't change anything I just downloaded the repo and then right so you want to put in the config G clock sample this is like near the end no sorry sorry just just go to the end and you see where yeah so you see it says options to add another line there that is and my face is over oh no yeah so then CFG it's the the word you want is right in the comment above yeah see it says just put that there and then make the the backslash on the line above this is like continuing as a long line yeah and just to confirm because make file cares about this you have two spaces at the beginning of that not a tab I just said that to me it needs to be two spaces yeah and then so you rebuild the microcode and try this again but also let's plot our the extra two counters that this will turn on for you which is the well it's they're already in the yield data footer right so I let me just do this stuff here we still want those right but they're gone because I just built that for the X yeah but you didn't change the source file right I've said I've pulled first no no I'm saying like we leave the source with the counters that we've just spent the last hour on right and then we're also turning on this other option which will give you the other counter that was that's the one for right but the version of 3d x3 that I have locally doesn't have these counters you just programmed I sent you the source code you just built it and you ran it on your rice okay nevermind I forgot about that part yeah so changing the makefile doesn't get rid of that right so yes so the reason I want that is actually not for the embarrassing how much time were you waiting for rambas but for the other counter which is how many micro how many display list commands it executed because if you're doing some ridiculous like tens of thousands of display list commands for some reason then that could explain some of the extra time though I kind of doubt it yeah I just want to know about and then I also yeah so another thing is this the triangle processing time would be counting the time for swapping to the clipping overlay and the vertex processing time would be counting time for swapping to the lighting okay neither of them would be counting time for swapping to the overlay for the like miscellaneous stuff the overlay for and again I don't think that's happening because if you were swapping like if you swapped to overlay for a hundred times you would also have to swap back from overlay for to either two or three yeah and those would be counted in the vertex time or the triangle time so I don't think that's the issue either but anyway yeah so you have the commands okay you've got those two so then yeah you just want to plot those I need this one I guess print them is yeah those two but you already have your global at least for that one oh looks like you're missing the second one the graphics command count oh yeah I didn't actually plot the gfx command count that was the I was getting confused with the FIFO okay so yeah so if you can just plot those as they should be just like a number of commands in hopefully less and you can just manually look at the ratio between them and so we have the gfx comments this is what do we want yeah yeah that's the only one I care about from the moment but since you're since you're doing it maybe you might as well plot the G clock alive one also just to get that info right and I don't do it actually I do that you're right here ma'am W already if you're already why am I dividing by GFX common count does that make sense that's the thing is like it's the percentage of time that okay okay so I just had to start us ma'am W and we just never looked at it before you can you can do it whichever which way you want to do it right so put a new fvdx3 and run it on n64 now or is anything else we need yes good but yeah you you did build the ex3 and copy the binary since you changed the makefile right and this is I'm doing the binary right now yeah you're building the binary the makefile may not notice that the makefile has changed so you may need to do make clean and yeah I can do that okay I just made haha Holly says Kaza you should sell your hack on the streets Nintendo will never find out it was a bizarre experience when I went to MagFest a couple of years ago I saw in one of the vendors booths they had a bunch of n64 repro carts with romhacks on and there was one that was the missing link and I like said to the seller oh like oh that's my you know I'm in that game it was like oh yeah yeah I worked on that but yeah we're seeing that for $50 that obviously none of that money is going to Nintendo but also that money is going to somebody is just taking our stuff and selling it so that's but you gotta you gotta have some tolerance for that in order to be in this yeah it's gonna happen maybe ruskies new boot code will prevent some of that hopefully but I also saw online stores that had like a hundred thousand sales of like people's romhacks they literally made millions of of that that's insane I don't really yes but they are like everything yeah you think people bought a hundred thousand people bought a repro cart of a single rom no no no of all the ones they selling together oh like the total their total sales overall yeah yeah oh yeah my wife wanted to just see what happens if she brings in the missing link it's like a cartridge to a game store to like sell it okay let me just limit the FPS again all right so this is 8,000 commands that's kind of similar to what I had in in OOT let me go back there let's see so for a normal normal place here so six thousand seven thousand that's okay that should not be the issue okay well that's that's good that we ruled out some ridiculous thing there I didn't get going sorry and the mem time is around twelve point eight milliseconds which is also more than I expected thought percentually it's gonna be less yeah so that you're doing that as can I see the code that you use to compute that because it matters which which direction you're doing because the G clock is alive time is the amount of time that the RDP is actually okay so yeah so that's the amount of time what you're plotting is the amount of time that the RDP is doing useful work and not stalling for memory oh okay command time which is the top that's your yeah RSP RDP command time no that's a clock that's not quite fair now you want to use clock time this is the clock time oh wait no is it not no it's command time oh you're right so cuz like if the RDP is actually I don't know which it would be if the RDP is just sitting there doing nothing whether it will show the G clock is alive or not I don't know so yeah if it's not if the artist I'm actually multiplying with the 33 here one way or the other it looks like it's about half the time it's a little more than half the time that is actually doing work which is great because in OOT it's like a third of like stalled two time and not stalled one third of time yeah it's not stalled just a little bit more than half so you're like substantially more efficient on the RDP which is what we all thought right yeah yeah okay so I have some good info here I'm gonna spend some time maybe over the next week or two And think about some other ways of profiling on the microcode and figure out what is actually going wrong. And then we can do this again in a couple weeks and see what happens. All right, I'm just gonna stash all these changes somewhere and then hopefully we can just start again where we left off. Sounds good. Thank you so much for having me on. Thanks for trying to help out and making the microcode. You're welcome. I really hope that I can end up making the Ramboscove room a little bit more. I think everybody in the community is really pumped about RTYI and I'm looking forward to playing myself. I hope I don't disappoint. All right, I'm gonna end the discord call then and you'll have to figure out what shows up on your screen then after that. All right, let me just see ya. Hello, are we back? I told you guys, as soon as I touch OBS, it just fucking dies. Hello, Holly.  unable to stash changes. Fucking awesome. Yo, we got a sup from Xena. What is this? Just make it a new branch. No, I don't want to work with fucking branches. I'm trying to discard my free files here. Trying to figure out how to. Yes, yes, yes. We basically we want more frames. If we can. More RDP time available to us. Okay, we're back to the old F3DX2. So this is what I was working on off stream this week, basically. This whole section and well, I guess I can show you the cave now with the lighting working. So meant by like faking the point lights. We just use a directional light like that. And of course, they have a bunch of milk. Because they're real cowboys. Oh, and he does that with Navi. I thought he used actual point lights. It's possible they're actual glow effects. What is an actual glow effect? All graphics are just about faking it, right? So what's your standard for when something counts as a glow effect? Like how well do you need to fake a glow for it to count? Oh, I don't know. Oh, that's interesting. All right. I think our next task should be first of all, let's fix this. Someone said this is wrong. Right. I see what she means by that. This is wrong. It should be kind of like that, but not quite. I think we might just have to change the texture here. Definitely Mario 64. I don't know. I, one time I said on my YouTube video that the N64 has a magically nostalgic aesthetic and then people said you're coping, you're cringe, you are nostalgia blinded. And then I didn't say that anymore. See, I always try to say something nice about the games in my videos, even if I think the games are garbage, because that gets you more views. But sometimes people are just like, nah. I mean, I can see a little bit of an argument that Dark Reign of Time is not as charming, because I guess they tried to be more like, oh, let's just make the graphics look like real life. Of course, it didn't look like real life at all, but you know what I mean? How many pixels are there? Three? Three. And it ends with the white. So let's have that be three here as well. This is what he wanted for the big logo, I think. Let's try and bring pixels on the bottom. Wait, no. Probably need just to know how. And that's what you're going to do about it. I know it should be seven parts, but I'm just going to subdivide this into eight just to be safe. I'm just going to subdivide this into eight just to be safe. I'm just going to subdivide this into eight just to be safe. Carting? Yes, carting. I'm just going to subdivide this into eight just to be safe. I'm just going to subdivide this into eight just to be safe. I'm just going to subdivide this into eight just to be safe. I'm just going to subdivide this into eight just to be safe. I think we're just going to go with this here. Somehow this wasn't even and I didn't realize. I'm just going to subdivide this into eight just to be safe. I'm just going to subdivide this into eight just to be safe. Butt joint would be cleaner. What is a butt joint? I honestly maybe I should just update OBS. Maybe that was just fix everything like instantly. It's not even that unlikely that that would happen. You can control that. And I think the reason it's not turned off is that they wanted it on. Maybe that was like a thing that Nintendo asked of developers as well. I would imagine it's like a thing that is just globally applied on the console because they believe it increases pixel like the way pixels look, which honestly I can kind of see. I mean, even nowadays, there are plenty of people that prefer the anti-aliasing being on. Wait, I didn't mean to select that one. I just think the A is too strong, but that might just be the fact that it's like flares of blur. Yeah. All kinds of people are getting mad at me over wanting people of the Project 64 hackability. Oh, whoops. It's too high up. Actually, no, it's not far enough down. And it has an issue with the drawing layer being the wrong. This definitely should be a layer one. And this should just be hard set to one. And you are fine. I have thought of feeding Gemini 1.5 your whole code base. I have not. That could be fun. Will we just have AI optimization at some point? That'd be crazy. All right, this looks good. Well, with speedrunning, you kind of have to make sure that there's parity between users. So everyone using the same shitty emulator is like the easiest way to make sure everyone is like on the same playing field. All right. I think this area is basically done. Did I miss anything? You guys seeing anything that I need to improve? We still got to add the train driving in a circle. And we got to add the timer. But those are pretty easy things. Yeah, I mean, you kind of want overclocking by default, right? Because it just makes it more playable. Are there going to be obstacles? Oh, shit. I got to add cactuses. Good point. I wanted to add the cactuses from the actual Calamari Desert. Did you put the dry bones in? There's no dry bones here. But I did put the dry bones in the other place. But I didn't animate them yet. All right. I think I've had a long enough stream, though. I got to check all the fires of people complaining about the video. So I will see you guys next Saturday. Until then. Bye bye.
